<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>seedir.folderstructure API documentation</title>
<meta name="description" content="The primary algorithm for determining the folder structure returned by
`seedir.realdir.seedir()` and `seedir.fakedir.FakeDir.seedir()`." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.15em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>seedir.folderstructure</code></h1>
</header>
<section id="section-intro">
<p>The primary algorithm for determining the folder structure returned by
<code><a title="seedir.realdir.seedir" href="realdir.html#seedir.realdir.seedir">seedir()</a></code> and <code><a title="seedir.fakedir.FakeDir.seedir" href="fakedir.html#seedir.fakedir.FakeDir.seedir">FakeDir.seedir()</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
The primary algorithm for determining the folder structure returned by
`seedir.realdir.seedir()` and `seedir.fakedir.FakeDir.seedir()`.

&#34;&#34;&#34;

import os
import warnings

import natsort

import seedir.printing as printing

def listdir_fullpath(path):
    &#39;&#39;&#39;Like `os.listdir()`, but returns absolute paths.&#39;&#39;&#39;
    return [os.path.join(path, f) for f in os.listdir(path)]

def formatter_update_args(formatter, item, args):
    &#39;&#39;&#39;
    Update a dictionary of style tokens based on a formatter function and
    an item.  Added in v 0.3.0 to support the addition of the formatter parameter
    for the seedir algorithm.

    Parameters
    ----------
    formatter : function
        Formatting function.
    item : file or folder item
        String or FakeItem produced in the seedir algorithm
    styleargs : dict
        Dictionary of seedir style tokens

    Returns
    -------
    styleargs : dict
        The input dictionary, after it may have been updated.

    &#39;&#39;&#39;
    newstyle = formatter(item)
    if newstyle is None:
        pass
    else:
        args.update(newstyle)

    return args

class FolderStructure:
    &#39;&#39;&#39;General class for determining folder strctures.  Implements
    the seedir folder-tree generating algorithm over arbitrary objects.&#39;&#39;&#39;

    def __init__(self, getname_func, isdir_func, listdir_func):
        &#39;&#39;&#39;
        Defines the functions used by `self` for generating folder structures.

        Parameters
        ----------
        getname_func : function
            Returns the name of the object.
        isdir_func : function
            Returns boolean of whether child object is a folder.
        listdir_func : function
            Function for returning the children of an object, given it is a
            &#34;folder&#34; as determined by `isdir_func`.  The child objects returned
            should be of similar type to `self`, such that the functions can
            be recursively applied.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.listdir = listdir_func
        self.isdir = isdir_func
        self.getname = getname_func

    def __call__(self, folder, style=&#39;lines&#39;, printout=True, indent=2, uniform=None,
                 anystart=None, anyend=None, depthlimit=None, itemlimit=None,
                 beyond=None, first=None, sort=False, sort_reverse=False,
                 sort_key=None, include_folders=None, exclude_folders=None,
                 include_files=None, exclude_files=None, regex=False, mask=None,
                 formatter=None, sticky_formatter=False, slash=None, **kwargs):
        &#39;&#39;&#39;Call this on a folder object to generate the seedir output
        for that object.&#39;&#39;&#39;

        accept_kwargs = [&#39;extend&#39;, &#39;split&#39;, &#39;space&#39;, &#39;final&#39;,
                         &#39;folderstart&#39;, &#39;filestart&#39;, &#39;folderend&#39;, &#39;fileend&#39;]

        if any(i not in accept_kwargs for i in kwargs.keys()):
            bad_kwargs = [i for i in kwargs.keys() if i not in accept_kwargs]
            raise ValueError(f&#39;kwargs must be any of {accept_kwargs}; &#39;
                             f&#39;unrecognized kwargs: {bad_kwargs}&#39;)

        styleargs = printing.get_styleargs(style)
        printing.format_indent(styleargs, indent=indent)

        if uniform is not None:
            for arg in [&#39;extend&#39;, &#39;split&#39;, &#39;final&#39;, &#39;space&#39;]:
                styleargs[arg] = uniform

        if anystart is not None:
            styleargs[&#39;folderstart&#39;] = anystart
            styleargs[&#39;filestart&#39;] = anystart

        if anyend is not None:
            styleargs[&#39;folderend&#39;] = anyend
            styleargs[&#39;fileend&#39;] = anyend

        if slash is not None:
            warnings.warn(&#34;`slash` will removed in a future version; &#34;
                          &#34;pass `folderend` as a keyword argument instead.&#34;,
                          DeprecationWarning)
            if slash.lower() in [&#39;sep&#39;, &#39;os.sep&#39;]:
                slash = os.sep
            styleargs[&#39;folderend&#39;] = slash

        for k in kwargs:
            if k in styleargs:
                styleargs[k] = kwargs[k]

        if sort_key is not None or sort_reverse == True:
            sort = True

        default_args = dict(depthlimit=depthlimit,
                            itemlimit=itemlimit,
                            beyond=beyond,
                            first=first,
                            sort=sort,
                            sort_reverse=sort_reverse,
                            sort_key=sort_key,
                            include_folders=include_folders,
                            exclude_folders=exclude_folders,
                            include_files=include_files,
                            exclude_files=exclude_files,
                            regex=regex,
                            mask=mask,
                            formatter=formatter,
                            sticky_formatter=sticky_formatter,
                            **styleargs)

        current_args = default_args.copy()

        # apply formatter to top level
        if formatter is not None:
            formatter_update_args(formatter, folder, current_args)

        if sticky_formatter:
            default_args = current_args

        s = self._folderstructure_recurse(folder, default_args, **current_args).strip()

        if printout:
            print(s)
        else:
            return s

    def beyond_depth_str(self, items, beyond):
        &#39;&#39;&#39;
        Generates the text when using the &#39;beyond&#39;
        parameter and ther are more items than the itemlimit or contents
        beyond the depthlimit.

        Parameters
        ----------
        beyond : str
            Style of beyond string to generate.  Options are:
                - &#39;ellipsis&#39; (&#39;...&#39;)
                - &#39;content&#39; or &#39;contents&#39; (the number of files and folders beyond)
                - a string starting with &#39;_&#39; (everything after the leading
                  underscore will be returned)
        items : collection of file paths, optional
            Path items of the items beyond the limit, used when the &#39;beyond&#39;
            argeument is &#39;content&#39; or &#39;contents&#39;. The default is None.


        Returns
        -------
        str
            String indicating what lies beyond

        &#39;&#39;&#39;
        if beyond.lower() == &#39;ellipsis&#39;:
            return &#39;...&#39;
        elif beyond.lower() in [&#39;contents&#39;,&#39;content&#39;]:
            folders = self.count_folders(items)
            files = self.count_files(items)
            return &#39;{} folder(s), {} file(s)&#39;.format(folders, files)
        elif beyond and beyond[0] == &#39;_&#39;:
            return beyond[1:]
        else:
            s1 = &#39;&#34;beyond&#34; must be &#34;ellipsis&#34;, &#34;content&#34;, or &#39;
            s2 = &#39;a string starting with &#34;_&#34;&#39;
            raise ValueError(s1 + s2)

    def count_files(self, items):
        &#39;&#39;&#39;
        Count the number of files in a collection of paths.

        Parameters
        ----------
        paths : list-like
            Collection of paths.

        Returns
        -------
        files : int
            Count of files.

        &#39;&#39;&#39;
        files = sum([not self.isdir(i) for i in items])
        return files

    def count_folders(self, items):
        &#39;&#39;&#39;
        Count the number of folders in a collection of paths.

        Parameters
        ----------
        paths : list-like
            Collection of paths.

        Returns
        -------
        files : int
            Count of folders.

        &#39;&#39;&#39;
        folders = sum([self.isdir(i) for i in items])
        return folders

    def filter_items(self, listdir, include_folders=None,
                      exclude_folders=None, include_files=None,
                      exclude_files=None, regex=False, mask=None):

        &#39;&#39;&#39;
        Filter for folder and file names in folder structures.  Removes or includes
        items matching filtering strings.

        Note the following priority of arguments:
            1. Mask (totally overwrites include/exclude)
            2. Include (saves items from being excluded)
            3. Exclude

        Parameters
        ----------
        listdir : list-like
            Collection of file/folder items.
        include_folders : str or list-like, optional
            Folder names to include. The default is None.
        exclude_folders : str or list-like, optional
            Folder names to exclude. The default is None.
        include_files : str or list-like, optional
            File names to include. The default is None.
        exclude_files : str or list-like, optional
            File names to exclude. The default is None.
        regex : bool, optional
            Interpret strings as regular expressions. The default is False.
        mask : function, optional
            Function for filtering items.  Absolute paths of each individual item
            are passed to the mask function.  If True is returned, the
            item is kept.  The default is None.

        Returns
        -------
        keep : list
            Filtered input.

        &#39;&#39;&#39;

        def _should_convert(x):
            return isinstance(x, str) or x is None

        filtered = []
        for item in listdir:

            name = self.getname(item)

            if self.isdir(item):
                inc = [include_folders] if _should_convert(include_folders) else include_folders
                exc = [exclude_folders] if _should_convert(exclude_folders) else exclude_folders
            else:
                inc = [include_files] if _should_convert(include_files) else include_files
                exc = [exclude_files] if _should_convert(exclude_files) else exclude_files

            # 1. check mask - which trumps include/exclude arguments
            if mask is not None:
                if mask(item):
                    filtered.append(item)
                continue

            # set default keep behavior
            # items are exluded if inclusion is passed
            keep = all([i is None for i in inc])

            # 2. apply exclusion
            for pat in exc:
                if pat is not None:
                    match = printing.is_match(pattern=pat, string=name, regex=regex)
                    if match:
                        keep = False

            # 3. apply inclusion (trumps exclusion)
            for pat in inc:
                if pat is not None:
                    match = printing.is_match(pattern=pat, string=name, regex=regex)
                    if match:
                        keep = True

            if keep:
                filtered.append(item)

        return filtered


    def _folderstructure_recurse(self, folder, default_args, depth=0, incomplete=None,
                                 extend=&#39;│ &#39;, space=&#39;  &#39;, split=&#39;├─&#39;, final=&#39;└─&#39;,
                                 filestart=&#39;&#39;, folderstart=&#39;&#39;, fileend=&#39;&#39;, folderend=&#39;/&#39;,
                                 depthlimit=None, itemlimit=None, beyond=None, first=None,
                                 sort=True, sort_reverse=False, sort_key=None,
                                 include_folders=None, exclude_folders=None,
                                 include_files=None, exclude_files=None,
                                 regex=False, mask=None, formatter=None, sticky_formatter=False):
        &#39;&#39;&#39;
        Main algorithm for creating folder structure string.  See
        `seedir.realdir.seedir()` or `seedir.fakedir.FakeDir.seedir()`
        for a description of the parameters.

        Note that since the expansion of the formatter parameter
        (version 0.3.1), the call &amp; logic has been slightly updated.
        Primarily, the `default_args` parameter has been added, to represent
        arguments to default to when the formatter is not in use.  The actual
        keyword arguments are treated as the options to be used for `folder`,
        and can change between iterations.  The `default_args` stay the same,
        unless `sticky_formatter` is used in combination with `formatter` to
        permanently update the default arguments.

        **In almost all cases, users should not need to call this function
        to generate diagrams**.  Rather, they should use the `__call__`
        method of a `FolderStructure` instance.

        &#39;&#39;&#39;

        # initialize
        output = &#39;&#39;

        if incomplete is None:
            incomplete = []

        # root string
        if depth == 0:

            d0args = {
                &#39;extend&#39;: extend,
                &#39;space&#39;: space,
                &#39;split&#39;: split,
                &#39;final&#39;: final,
                &#39;filestart&#39;: filestart,
                &#39;folderstart&#39;: folderstart,
                &#39;fileend&#39; : fileend,
                &#39;folderend&#39;: folderend
                }

            if formatter is not None:
                formatter_update_args(formatter, folder, d0args)
            output += (d0args[&#39;folderstart&#39;] +
                       self.getname(folder) +
                       d0args[&#39;folderend&#39;] +
                       &#39;\n&#39;)


        current_itemlimit = itemlimit
        beyond_added = False

        # handle when depthlimit is reached
        if isinstance(depthlimit, int) and depth &gt;= depthlimit:
            if beyond is None:
                return output
            else:
                current_itemlimit = 0

        # get all children, add depth to docket
        listdir = self.listdir(folder)
        incomplete.append(depth)

        # sort and filter the contents of listdir
        sortargs = {
            &#39;first&#39;: first,
            &#39;sort_reverse&#39;: sort_reverse,
            &#39;sort_key&#39;: sort_key}

        filterargs = {
            &#39;include_folders&#39;: include_folders,
            &#39;exclude_folders&#39;: exclude_folders,
            &#39;include_files&#39; : include_files,
            &#39;exclude_files&#39;: exclude_files,
            &#39;mask&#39;: mask
            }

        if sort or first is not None:
            listdir = self.sort_dir(listdir, **sortargs)

        if any(arg is not None for arg in filterargs.values()):
            listdir = self.filter_items(listdir, **filterargs, regex=regex)

        # set current_itemlimit based on listdir size
        if current_itemlimit is None:
            current_itemlimit = len(listdir)
        else:
            current_itemlimit = min(current_itemlimit, len(listdir))

        # segment output into what can be included
        finalpaths = listdir[:current_itemlimit]
        rem = listdir[current_itemlimit:]

        # append beyond string if being used
        if beyond is not None:
            if rem or (depth == depthlimit):
                finalpaths += [self.beyond_depth_str(rem, beyond)]
                beyond_added = True

        # if empty, close the current depth
        if not finalpaths:
            incomplete.remove(depth)

        # get output for each item in folder
        for i, f in enumerate(finalpaths):

            current_args = default_args.copy() # used in this iteration
            next_default_args = default_args   # passed to child

            lastitem = (i == (len(finalpaths) - 1))
            isbeyondstr = lastitem and beyond_added
            name = f if isbeyondstr else self.getname(f)

            # update tokens with formatter if passed
            if not isbeyondstr and formatter is not None:
                formatter_update_args(formatter, f, current_args)

            if sticky_formatter:
                next_default_args = current_args

            # create header for the item
            base_header = self.get_base_header(incomplete,
                                               current_args[&#39;extend&#39;],
                                               current_args[&#39;space&#39;])

            if lastitem:
                branch = current_args[&#39;final&#39;]
                incomplete.remove(depth)
            else:
                branch = current_args[&#39;split&#39;]

            header = base_header + branch

            # concat to output and recurse if item is folder
            if not isbeyondstr and self.isdir(f):
                output += (header +
                           current_args[&#39;folderstart&#39;] +
                           name +
                           current_args[&#39;folderend&#39;] +
                           &#39;\n&#39;)
                output += self._folderstructure_recurse(f, depth=depth + 1,
                                                        incomplete=incomplete,
                                                        default_args=next_default_args,
                                                        **current_args)

            # only concat to output if file
            else:
                output += (header +
                           current_args[&#39;filestart&#39;] +
                           name +
                           current_args[&#39;fileend&#39;] +
                           &#39;\n&#39;)

        return output

    def get_base_header(self, incomplete, extend, space):
        &#39;&#39;&#39;
        For folder structures, generate the combination of extend and space
        tokens to prepend to file names when generating folder diagrams.


        The string generated here will still be missing the branch token
        (split or final) as well as any folderstart or filestart tokens.
        They are added within seedir.seedir().

        For any item included in a folder diagram, the combination of
        extend and space tokens is based on the depth of the item as well as the
        parent folders to that item which are not completed.  This information
        is symbolized with the `incomplete` argument.  The following illustrates
        the incomplete arguments passed to this function for an example folder
        tree:

        ```
        doc/
        ├─_static/                  [0]
        │ ├─embedded/               [0, 1]
        │ │ ├─deep_file             [0, 1, 2]
        │ │ └─very/                 [0, 1, 2]
        │ │   └─deep/               [0, 1, 3]
        │ │     └─folder/           [0, 1, 4]
        │ │       └─very_deep_file  [0, 1, 5]
        │ └─less_deep_file          [0, 1]
        └─index.rst                 [0]
        ```

        Parameters
        ----------
        incomplete : list-like
            List of integers denoting the depth of incomplete folders at the time
            of constructing the line for a given item.  Zero represents being
            inside the main folder, with increasing integers meaing increasing
            depth.
        extend : str
            Characters symbolizing the extension of a folder.
        space : str
            Characters providing the gap between items and earlier parents.

        Returns
        -------
        str
            Base header string.

        &#39;&#39;&#39;
        base_header = []
        max_i = max(incomplete)
        for p in range(max_i):
            if p in incomplete:
                base_header.append(extend)
            else:
                base_header.append(space)
        return &#34;&#34;.join(base_header)

    def sort_dir(self, items, first=None, sort_reverse=False, sort_key=None):
        &#39;&#39;&#39;
        Sorting function used to sort contents when producing folder diagrams.

        Parameters
        ----------
        items : list-like
            Collection of folder contents.
        first : &#39;files&#39; or &#39;folders&#39;, optional
            Sort either files or folders first. The default is None.
        sort_reverse : bool, optional
            Reverse the sort applied. The default is False.
        sort_key : function, optional
            Function to apply to sort the objs by their basename.  The function
            should take a single argument, of the type expected by
            this FolderStucture.

        Returns
        -------
        list
            Sorted input as a list.

        &#39;&#39;&#39;
        if sort_key is None:
            key = lambda x : self.getname(x)
        else:
            key = lambda x: sort_key(self.getname(x))

        if first in [&#39;folders&#39;, &#39;files&#39;]:
            folders = [p for p in items if self.isdir(p)]
            files = [p for p in items if not self.isdir(p)]
            folders = natsort.natsorted(folders, reverse=sort_reverse, key=key)
            files = natsort.natsorted(files, reverse=sort_reverse, key=key)
            output = folders + files if first == &#39;folders&#39; else files + folders
        elif first is None:
            output = list(natsort.natsorted(items, reverse=sort_reverse, key=key))
        else:
            raise ValueError(&#34;`first` must be &#39;folders&#39;, &#39;files&#39;, or None.&#34;)

        return output

slashes = os.sep + &#39;/&#39; + &#39;//&#39;

RealDirStructure = FolderStructure(getname_func = lambda x: os.path.basename(x.rstrip(slashes)),
                                   isdir_func = lambda x: os.path.isdir(x),
                                   listdir_func = listdir_fullpath)
&#34;&#34;&#34;Object for making real folder structures from string paths.&#34;&#34;&#34;

PathlibStructure = FolderStructure(getname_func = lambda x: x.name,
                                   isdir_func = lambda x: x.is_dir(),
                                   listdir_func = lambda x: list(x.iterdir()))
&#34;&#34;&#34;Object for making real folder structures from pathlib objects.&#34;&#34;&#34;

FakeDirStructure = FolderStructure(getname_func = lambda x: x.name,
                                   isdir_func = lambda x: x.isdir(),
                                   listdir_func = lambda x: x.listdir())
&#34;&#34;&#34;Object for making fake folder structures.&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="seedir.folderstructure.FakeDirStructure"><code class="name">var <span class="ident">FakeDirStructure</span></code></dt>
<dd>
<div class="desc"><p>Object for making fake folder structures.</p></div>
</dd>
<dt id="seedir.folderstructure.PathlibStructure"><code class="name">var <span class="ident">PathlibStructure</span></code></dt>
<dd>
<div class="desc"><p>Object for making real folder structures from pathlib objects.</p></div>
</dd>
<dt id="seedir.folderstructure.RealDirStructure"><code class="name">var <span class="ident">RealDirStructure</span></code></dt>
<dd>
<div class="desc"><p>Object for making real folder structures from string paths.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="seedir.folderstructure.formatter_update_args"><code class="name flex">
<span>def <span class="ident">formatter_update_args</span></span>(<span>formatter, item, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a dictionary of style tokens based on a formatter function and
an item.
Added in v 0.3.0 to support the addition of the formatter parameter
for the seedir algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formatter</code></strong> :&ensp;<code>function</code></dt>
<dd>Formatting function.</dd>
<dt><strong><code>item</code></strong> :&ensp;<code>file</code> or <code>folder item</code></dt>
<dd>String or FakeItem produced in the seedir algorithm</dd>
<dt><strong><code>styleargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of seedir style tokens</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>styleargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The input dictionary, after it may have been updated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatter_update_args(formatter, item, args):
    &#39;&#39;&#39;
    Update a dictionary of style tokens based on a formatter function and
    an item.  Added in v 0.3.0 to support the addition of the formatter parameter
    for the seedir algorithm.

    Parameters
    ----------
    formatter : function
        Formatting function.
    item : file or folder item
        String or FakeItem produced in the seedir algorithm
    styleargs : dict
        Dictionary of seedir style tokens

    Returns
    -------
    styleargs : dict
        The input dictionary, after it may have been updated.

    &#39;&#39;&#39;
    newstyle = formatter(item)
    if newstyle is None:
        pass
    else:
        args.update(newstyle)

    return args</code></pre>
</details>
</dd>
<dt id="seedir.folderstructure.listdir_fullpath"><code class="name flex">
<span>def <span class="ident">listdir_fullpath</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Like <code>os.listdir()</code>, but returns absolute paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listdir_fullpath(path):
    &#39;&#39;&#39;Like `os.listdir()`, but returns absolute paths.&#39;&#39;&#39;
    return [os.path.join(path, f) for f in os.listdir(path)]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="seedir.folderstructure.FolderStructure"><code class="flex name class">
<span>class <span class="ident">FolderStructure</span></span>
<span>(</span><span>getname_func, isdir_func, listdir_func)</span>
</code></dt>
<dd>
<div class="desc"><p>General class for determining folder strctures.
Implements
the seedir folder-tree generating algorithm over arbitrary objects.</p>
<p>Defines the functions used by <code>self</code> for generating folder structures.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>getname_func</code></strong> :&ensp;<code>function</code></dt>
<dd>Returns the name of the object.</dd>
<dt><strong><code>isdir_func</code></strong> :&ensp;<code>function</code></dt>
<dd>Returns boolean of whether child object is a folder.</dd>
<dt><strong><code>listdir_func</code></strong> :&ensp;<code>function</code></dt>
<dd>Function for returning the children of an object, given it is a
"folder" as determined by <code>isdir_func</code>.
The child objects returned
should be of similar type to <code>self</code>, such that the functions can
be recursively applied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FolderStructure:
    &#39;&#39;&#39;General class for determining folder strctures.  Implements
    the seedir folder-tree generating algorithm over arbitrary objects.&#39;&#39;&#39;

    def __init__(self, getname_func, isdir_func, listdir_func):
        &#39;&#39;&#39;
        Defines the functions used by `self` for generating folder structures.

        Parameters
        ----------
        getname_func : function
            Returns the name of the object.
        isdir_func : function
            Returns boolean of whether child object is a folder.
        listdir_func : function
            Function for returning the children of an object, given it is a
            &#34;folder&#34; as determined by `isdir_func`.  The child objects returned
            should be of similar type to `self`, such that the functions can
            be recursively applied.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.listdir = listdir_func
        self.isdir = isdir_func
        self.getname = getname_func

    def __call__(self, folder, style=&#39;lines&#39;, printout=True, indent=2, uniform=None,
                 anystart=None, anyend=None, depthlimit=None, itemlimit=None,
                 beyond=None, first=None, sort=False, sort_reverse=False,
                 sort_key=None, include_folders=None, exclude_folders=None,
                 include_files=None, exclude_files=None, regex=False, mask=None,
                 formatter=None, sticky_formatter=False, slash=None, **kwargs):
        &#39;&#39;&#39;Call this on a folder object to generate the seedir output
        for that object.&#39;&#39;&#39;

        accept_kwargs = [&#39;extend&#39;, &#39;split&#39;, &#39;space&#39;, &#39;final&#39;,
                         &#39;folderstart&#39;, &#39;filestart&#39;, &#39;folderend&#39;, &#39;fileend&#39;]

        if any(i not in accept_kwargs for i in kwargs.keys()):
            bad_kwargs = [i for i in kwargs.keys() if i not in accept_kwargs]
            raise ValueError(f&#39;kwargs must be any of {accept_kwargs}; &#39;
                             f&#39;unrecognized kwargs: {bad_kwargs}&#39;)

        styleargs = printing.get_styleargs(style)
        printing.format_indent(styleargs, indent=indent)

        if uniform is not None:
            for arg in [&#39;extend&#39;, &#39;split&#39;, &#39;final&#39;, &#39;space&#39;]:
                styleargs[arg] = uniform

        if anystart is not None:
            styleargs[&#39;folderstart&#39;] = anystart
            styleargs[&#39;filestart&#39;] = anystart

        if anyend is not None:
            styleargs[&#39;folderend&#39;] = anyend
            styleargs[&#39;fileend&#39;] = anyend

        if slash is not None:
            warnings.warn(&#34;`slash` will removed in a future version; &#34;
                          &#34;pass `folderend` as a keyword argument instead.&#34;,
                          DeprecationWarning)
            if slash.lower() in [&#39;sep&#39;, &#39;os.sep&#39;]:
                slash = os.sep
            styleargs[&#39;folderend&#39;] = slash

        for k in kwargs:
            if k in styleargs:
                styleargs[k] = kwargs[k]

        if sort_key is not None or sort_reverse == True:
            sort = True

        default_args = dict(depthlimit=depthlimit,
                            itemlimit=itemlimit,
                            beyond=beyond,
                            first=first,
                            sort=sort,
                            sort_reverse=sort_reverse,
                            sort_key=sort_key,
                            include_folders=include_folders,
                            exclude_folders=exclude_folders,
                            include_files=include_files,
                            exclude_files=exclude_files,
                            regex=regex,
                            mask=mask,
                            formatter=formatter,
                            sticky_formatter=sticky_formatter,
                            **styleargs)

        current_args = default_args.copy()

        # apply formatter to top level
        if formatter is not None:
            formatter_update_args(formatter, folder, current_args)

        if sticky_formatter:
            default_args = current_args

        s = self._folderstructure_recurse(folder, default_args, **current_args).strip()

        if printout:
            print(s)
        else:
            return s

    def beyond_depth_str(self, items, beyond):
        &#39;&#39;&#39;
        Generates the text when using the &#39;beyond&#39;
        parameter and ther are more items than the itemlimit or contents
        beyond the depthlimit.

        Parameters
        ----------
        beyond : str
            Style of beyond string to generate.  Options are:
                - &#39;ellipsis&#39; (&#39;...&#39;)
                - &#39;content&#39; or &#39;contents&#39; (the number of files and folders beyond)
                - a string starting with &#39;_&#39; (everything after the leading
                  underscore will be returned)
        items : collection of file paths, optional
            Path items of the items beyond the limit, used when the &#39;beyond&#39;
            argeument is &#39;content&#39; or &#39;contents&#39;. The default is None.


        Returns
        -------
        str
            String indicating what lies beyond

        &#39;&#39;&#39;
        if beyond.lower() == &#39;ellipsis&#39;:
            return &#39;...&#39;
        elif beyond.lower() in [&#39;contents&#39;,&#39;content&#39;]:
            folders = self.count_folders(items)
            files = self.count_files(items)
            return &#39;{} folder(s), {} file(s)&#39;.format(folders, files)
        elif beyond and beyond[0] == &#39;_&#39;:
            return beyond[1:]
        else:
            s1 = &#39;&#34;beyond&#34; must be &#34;ellipsis&#34;, &#34;content&#34;, or &#39;
            s2 = &#39;a string starting with &#34;_&#34;&#39;
            raise ValueError(s1 + s2)

    def count_files(self, items):
        &#39;&#39;&#39;
        Count the number of files in a collection of paths.

        Parameters
        ----------
        paths : list-like
            Collection of paths.

        Returns
        -------
        files : int
            Count of files.

        &#39;&#39;&#39;
        files = sum([not self.isdir(i) for i in items])
        return files

    def count_folders(self, items):
        &#39;&#39;&#39;
        Count the number of folders in a collection of paths.

        Parameters
        ----------
        paths : list-like
            Collection of paths.

        Returns
        -------
        files : int
            Count of folders.

        &#39;&#39;&#39;
        folders = sum([self.isdir(i) for i in items])
        return folders

    def filter_items(self, listdir, include_folders=None,
                      exclude_folders=None, include_files=None,
                      exclude_files=None, regex=False, mask=None):

        &#39;&#39;&#39;
        Filter for folder and file names in folder structures.  Removes or includes
        items matching filtering strings.

        Note the following priority of arguments:
            1. Mask (totally overwrites include/exclude)
            2. Include (saves items from being excluded)
            3. Exclude

        Parameters
        ----------
        listdir : list-like
            Collection of file/folder items.
        include_folders : str or list-like, optional
            Folder names to include. The default is None.
        exclude_folders : str or list-like, optional
            Folder names to exclude. The default is None.
        include_files : str or list-like, optional
            File names to include. The default is None.
        exclude_files : str or list-like, optional
            File names to exclude. The default is None.
        regex : bool, optional
            Interpret strings as regular expressions. The default is False.
        mask : function, optional
            Function for filtering items.  Absolute paths of each individual item
            are passed to the mask function.  If True is returned, the
            item is kept.  The default is None.

        Returns
        -------
        keep : list
            Filtered input.

        &#39;&#39;&#39;

        def _should_convert(x):
            return isinstance(x, str) or x is None

        filtered = []
        for item in listdir:

            name = self.getname(item)

            if self.isdir(item):
                inc = [include_folders] if _should_convert(include_folders) else include_folders
                exc = [exclude_folders] if _should_convert(exclude_folders) else exclude_folders
            else:
                inc = [include_files] if _should_convert(include_files) else include_files
                exc = [exclude_files] if _should_convert(exclude_files) else exclude_files

            # 1. check mask - which trumps include/exclude arguments
            if mask is not None:
                if mask(item):
                    filtered.append(item)
                continue

            # set default keep behavior
            # items are exluded if inclusion is passed
            keep = all([i is None for i in inc])

            # 2. apply exclusion
            for pat in exc:
                if pat is not None:
                    match = printing.is_match(pattern=pat, string=name, regex=regex)
                    if match:
                        keep = False

            # 3. apply inclusion (trumps exclusion)
            for pat in inc:
                if pat is not None:
                    match = printing.is_match(pattern=pat, string=name, regex=regex)
                    if match:
                        keep = True

            if keep:
                filtered.append(item)

        return filtered


    def _folderstructure_recurse(self, folder, default_args, depth=0, incomplete=None,
                                 extend=&#39;│ &#39;, space=&#39;  &#39;, split=&#39;├─&#39;, final=&#39;└─&#39;,
                                 filestart=&#39;&#39;, folderstart=&#39;&#39;, fileend=&#39;&#39;, folderend=&#39;/&#39;,
                                 depthlimit=None, itemlimit=None, beyond=None, first=None,
                                 sort=True, sort_reverse=False, sort_key=None,
                                 include_folders=None, exclude_folders=None,
                                 include_files=None, exclude_files=None,
                                 regex=False, mask=None, formatter=None, sticky_formatter=False):
        &#39;&#39;&#39;
        Main algorithm for creating folder structure string.  See
        `seedir.realdir.seedir()` or `seedir.fakedir.FakeDir.seedir()`
        for a description of the parameters.

        Note that since the expansion of the formatter parameter
        (version 0.3.1), the call &amp; logic has been slightly updated.
        Primarily, the `default_args` parameter has been added, to represent
        arguments to default to when the formatter is not in use.  The actual
        keyword arguments are treated as the options to be used for `folder`,
        and can change between iterations.  The `default_args` stay the same,
        unless `sticky_formatter` is used in combination with `formatter` to
        permanently update the default arguments.

        **In almost all cases, users should not need to call this function
        to generate diagrams**.  Rather, they should use the `__call__`
        method of a `FolderStructure` instance.

        &#39;&#39;&#39;

        # initialize
        output = &#39;&#39;

        if incomplete is None:
            incomplete = []

        # root string
        if depth == 0:

            d0args = {
                &#39;extend&#39;: extend,
                &#39;space&#39;: space,
                &#39;split&#39;: split,
                &#39;final&#39;: final,
                &#39;filestart&#39;: filestart,
                &#39;folderstart&#39;: folderstart,
                &#39;fileend&#39; : fileend,
                &#39;folderend&#39;: folderend
                }

            if formatter is not None:
                formatter_update_args(formatter, folder, d0args)
            output += (d0args[&#39;folderstart&#39;] +
                       self.getname(folder) +
                       d0args[&#39;folderend&#39;] +
                       &#39;\n&#39;)


        current_itemlimit = itemlimit
        beyond_added = False

        # handle when depthlimit is reached
        if isinstance(depthlimit, int) and depth &gt;= depthlimit:
            if beyond is None:
                return output
            else:
                current_itemlimit = 0

        # get all children, add depth to docket
        listdir = self.listdir(folder)
        incomplete.append(depth)

        # sort and filter the contents of listdir
        sortargs = {
            &#39;first&#39;: first,
            &#39;sort_reverse&#39;: sort_reverse,
            &#39;sort_key&#39;: sort_key}

        filterargs = {
            &#39;include_folders&#39;: include_folders,
            &#39;exclude_folders&#39;: exclude_folders,
            &#39;include_files&#39; : include_files,
            &#39;exclude_files&#39;: exclude_files,
            &#39;mask&#39;: mask
            }

        if sort or first is not None:
            listdir = self.sort_dir(listdir, **sortargs)

        if any(arg is not None for arg in filterargs.values()):
            listdir = self.filter_items(listdir, **filterargs, regex=regex)

        # set current_itemlimit based on listdir size
        if current_itemlimit is None:
            current_itemlimit = len(listdir)
        else:
            current_itemlimit = min(current_itemlimit, len(listdir))

        # segment output into what can be included
        finalpaths = listdir[:current_itemlimit]
        rem = listdir[current_itemlimit:]

        # append beyond string if being used
        if beyond is not None:
            if rem or (depth == depthlimit):
                finalpaths += [self.beyond_depth_str(rem, beyond)]
                beyond_added = True

        # if empty, close the current depth
        if not finalpaths:
            incomplete.remove(depth)

        # get output for each item in folder
        for i, f in enumerate(finalpaths):

            current_args = default_args.copy() # used in this iteration
            next_default_args = default_args   # passed to child

            lastitem = (i == (len(finalpaths) - 1))
            isbeyondstr = lastitem and beyond_added
            name = f if isbeyondstr else self.getname(f)

            # update tokens with formatter if passed
            if not isbeyondstr and formatter is not None:
                formatter_update_args(formatter, f, current_args)

            if sticky_formatter:
                next_default_args = current_args

            # create header for the item
            base_header = self.get_base_header(incomplete,
                                               current_args[&#39;extend&#39;],
                                               current_args[&#39;space&#39;])

            if lastitem:
                branch = current_args[&#39;final&#39;]
                incomplete.remove(depth)
            else:
                branch = current_args[&#39;split&#39;]

            header = base_header + branch

            # concat to output and recurse if item is folder
            if not isbeyondstr and self.isdir(f):
                output += (header +
                           current_args[&#39;folderstart&#39;] +
                           name +
                           current_args[&#39;folderend&#39;] +
                           &#39;\n&#39;)
                output += self._folderstructure_recurse(f, depth=depth + 1,
                                                        incomplete=incomplete,
                                                        default_args=next_default_args,
                                                        **current_args)

            # only concat to output if file
            else:
                output += (header +
                           current_args[&#39;filestart&#39;] +
                           name +
                           current_args[&#39;fileend&#39;] +
                           &#39;\n&#39;)

        return output

    def get_base_header(self, incomplete, extend, space):
        &#39;&#39;&#39;
        For folder structures, generate the combination of extend and space
        tokens to prepend to file names when generating folder diagrams.


        The string generated here will still be missing the branch token
        (split or final) as well as any folderstart or filestart tokens.
        They are added within seedir.seedir().

        For any item included in a folder diagram, the combination of
        extend and space tokens is based on the depth of the item as well as the
        parent folders to that item which are not completed.  This information
        is symbolized with the `incomplete` argument.  The following illustrates
        the incomplete arguments passed to this function for an example folder
        tree:

        ```
        doc/
        ├─_static/                  [0]
        │ ├─embedded/               [0, 1]
        │ │ ├─deep_file             [0, 1, 2]
        │ │ └─very/                 [0, 1, 2]
        │ │   └─deep/               [0, 1, 3]
        │ │     └─folder/           [0, 1, 4]
        │ │       └─very_deep_file  [0, 1, 5]
        │ └─less_deep_file          [0, 1]
        └─index.rst                 [0]
        ```

        Parameters
        ----------
        incomplete : list-like
            List of integers denoting the depth of incomplete folders at the time
            of constructing the line for a given item.  Zero represents being
            inside the main folder, with increasing integers meaing increasing
            depth.
        extend : str
            Characters symbolizing the extension of a folder.
        space : str
            Characters providing the gap between items and earlier parents.

        Returns
        -------
        str
            Base header string.

        &#39;&#39;&#39;
        base_header = []
        max_i = max(incomplete)
        for p in range(max_i):
            if p in incomplete:
                base_header.append(extend)
            else:
                base_header.append(space)
        return &#34;&#34;.join(base_header)

    def sort_dir(self, items, first=None, sort_reverse=False, sort_key=None):
        &#39;&#39;&#39;
        Sorting function used to sort contents when producing folder diagrams.

        Parameters
        ----------
        items : list-like
            Collection of folder contents.
        first : &#39;files&#39; or &#39;folders&#39;, optional
            Sort either files or folders first. The default is None.
        sort_reverse : bool, optional
            Reverse the sort applied. The default is False.
        sort_key : function, optional
            Function to apply to sort the objs by their basename.  The function
            should take a single argument, of the type expected by
            this FolderStucture.

        Returns
        -------
        list
            Sorted input as a list.

        &#39;&#39;&#39;
        if sort_key is None:
            key = lambda x : self.getname(x)
        else:
            key = lambda x: sort_key(self.getname(x))

        if first in [&#39;folders&#39;, &#39;files&#39;]:
            folders = [p for p in items if self.isdir(p)]
            files = [p for p in items if not self.isdir(p)]
            folders = natsort.natsorted(folders, reverse=sort_reverse, key=key)
            files = natsort.natsorted(files, reverse=sort_reverse, key=key)
            output = folders + files if first == &#39;folders&#39; else files + folders
        elif first is None:
            output = list(natsort.natsorted(items, reverse=sort_reverse, key=key))
        else:
            raise ValueError(&#34;`first` must be &#39;folders&#39;, &#39;files&#39;, or None.&#34;)

        return output</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="seedir.folderstructure.FolderStructure.beyond_depth_str"><code class="name flex">
<span>def <span class="ident">beyond_depth_str</span></span>(<span>self, items, beyond)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the text when using the 'beyond'
parameter and ther are more items than the itemlimit or contents
beyond the depthlimit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>beyond</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of beyond string to generate.
Options are:
- 'ellipsis' ('&hellip;')
- 'content' or 'contents' (the number of files and folders beyond)
- a string starting with '_' (everything after the leading
underscore will be returned)</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>collection</code> of <code>file paths</code>, optional</dt>
<dd>Path items of the items beyond the limit, used when the 'beyond'
argeument is 'content' or 'contents'. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>String indicating what lies beyond</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beyond_depth_str(self, items, beyond):
    &#39;&#39;&#39;
    Generates the text when using the &#39;beyond&#39;
    parameter and ther are more items than the itemlimit or contents
    beyond the depthlimit.

    Parameters
    ----------
    beyond : str
        Style of beyond string to generate.  Options are:
            - &#39;ellipsis&#39; (&#39;...&#39;)
            - &#39;content&#39; or &#39;contents&#39; (the number of files and folders beyond)
            - a string starting with &#39;_&#39; (everything after the leading
              underscore will be returned)
    items : collection of file paths, optional
        Path items of the items beyond the limit, used when the &#39;beyond&#39;
        argeument is &#39;content&#39; or &#39;contents&#39;. The default is None.


    Returns
    -------
    str
        String indicating what lies beyond

    &#39;&#39;&#39;
    if beyond.lower() == &#39;ellipsis&#39;:
        return &#39;...&#39;
    elif beyond.lower() in [&#39;contents&#39;,&#39;content&#39;]:
        folders = self.count_folders(items)
        files = self.count_files(items)
        return &#39;{} folder(s), {} file(s)&#39;.format(folders, files)
    elif beyond and beyond[0] == &#39;_&#39;:
        return beyond[1:]
    else:
        s1 = &#39;&#34;beyond&#34; must be &#34;ellipsis&#34;, &#34;content&#34;, or &#39;
        s2 = &#39;a string starting with &#34;_&#34;&#39;
        raise ValueError(s1 + s2)</code></pre>
</details>
</dd>
<dt id="seedir.folderstructure.FolderStructure.count_files"><code class="name flex">
<span>def <span class="ident">count_files</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of files in a collection of paths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of paths.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>int</code></dt>
<dd>Count of files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_files(self, items):
    &#39;&#39;&#39;
    Count the number of files in a collection of paths.

    Parameters
    ----------
    paths : list-like
        Collection of paths.

    Returns
    -------
    files : int
        Count of files.

    &#39;&#39;&#39;
    files = sum([not self.isdir(i) for i in items])
    return files</code></pre>
</details>
</dd>
<dt id="seedir.folderstructure.FolderStructure.count_folders"><code class="name flex">
<span>def <span class="ident">count_folders</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of folders in a collection of paths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of paths.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>int</code></dt>
<dd>Count of folders.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_folders(self, items):
    &#39;&#39;&#39;
    Count the number of folders in a collection of paths.

    Parameters
    ----------
    paths : list-like
        Collection of paths.

    Returns
    -------
    files : int
        Count of folders.

    &#39;&#39;&#39;
    folders = sum([self.isdir(i) for i in items])
    return folders</code></pre>
</details>
</dd>
<dt id="seedir.folderstructure.FolderStructure.filter_items"><code class="name flex">
<span>def <span class="ident">filter_items</span></span>(<span>self, listdir, include_folders=None, exclude_folders=None, include_files=None, exclude_files=None, regex=False, mask=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter for folder and file names in folder structures.
Removes or includes
items matching filtering strings.</p>
<p>Note the following priority of arguments:
1. Mask (totally overwrites include/exclude)
2. Include (saves items from being excluded)
3. Exclude</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>listdir</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of file/folder items.</dd>
<dt><strong><code>include_folders</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>Folder names to include. The default is None.</dd>
<dt><strong><code>exclude_folders</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>Folder names to exclude. The default is None.</dd>
<dt><strong><code>include_files</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>File names to include. The default is None.</dd>
<dt><strong><code>exclude_files</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>File names to exclude. The default is None.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Interpret strings as regular expressions. The default is False.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function for filtering items.
Absolute paths of each individual item
are passed to the mask function.
If True is returned, the
item is kept.
The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>keep</code></strong> :&ensp;<code>list</code></dt>
<dd>Filtered input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_items(self, listdir, include_folders=None,
                  exclude_folders=None, include_files=None,
                  exclude_files=None, regex=False, mask=None):

    &#39;&#39;&#39;
    Filter for folder and file names in folder structures.  Removes or includes
    items matching filtering strings.

    Note the following priority of arguments:
        1. Mask (totally overwrites include/exclude)
        2. Include (saves items from being excluded)
        3. Exclude

    Parameters
    ----------
    listdir : list-like
        Collection of file/folder items.
    include_folders : str or list-like, optional
        Folder names to include. The default is None.
    exclude_folders : str or list-like, optional
        Folder names to exclude. The default is None.
    include_files : str or list-like, optional
        File names to include. The default is None.
    exclude_files : str or list-like, optional
        File names to exclude. The default is None.
    regex : bool, optional
        Interpret strings as regular expressions. The default is False.
    mask : function, optional
        Function for filtering items.  Absolute paths of each individual item
        are passed to the mask function.  If True is returned, the
        item is kept.  The default is None.

    Returns
    -------
    keep : list
        Filtered input.

    &#39;&#39;&#39;

    def _should_convert(x):
        return isinstance(x, str) or x is None

    filtered = []
    for item in listdir:

        name = self.getname(item)

        if self.isdir(item):
            inc = [include_folders] if _should_convert(include_folders) else include_folders
            exc = [exclude_folders] if _should_convert(exclude_folders) else exclude_folders
        else:
            inc = [include_files] if _should_convert(include_files) else include_files
            exc = [exclude_files] if _should_convert(exclude_files) else exclude_files

        # 1. check mask - which trumps include/exclude arguments
        if mask is not None:
            if mask(item):
                filtered.append(item)
            continue

        # set default keep behavior
        # items are exluded if inclusion is passed
        keep = all([i is None for i in inc])

        # 2. apply exclusion
        for pat in exc:
            if pat is not None:
                match = printing.is_match(pattern=pat, string=name, regex=regex)
                if match:
                    keep = False

        # 3. apply inclusion (trumps exclusion)
        for pat in inc:
            if pat is not None:
                match = printing.is_match(pattern=pat, string=name, regex=regex)
                if match:
                    keep = True

        if keep:
            filtered.append(item)

    return filtered</code></pre>
</details>
</dd>
<dt id="seedir.folderstructure.FolderStructure.get_base_header"><code class="name flex">
<span>def <span class="ident">get_base_header</span></span>(<span>self, incomplete, extend, space)</span>
</code></dt>
<dd>
<div class="desc"><p>For folder structures, generate the combination of extend and space
tokens to prepend to file names when generating folder diagrams.</p>
<p>The string generated here will still be missing the branch token
(split or final) as well as any folderstart or filestart tokens.
They are added within seedir.seedir().</p>
<p>For any item included in a folder diagram, the combination of
extend and space tokens is based on the depth of the item as well as the
parent folders to that item which are not completed.
This information
is symbolized with the <code>incomplete</code> argument.
The following illustrates
the incomplete arguments passed to this function for an example folder
tree:</p>
<pre><code>doc/
├─_static/                  [0]
│ ├─embedded/               [0, 1]
│ │ ├─deep_file             [0, 1, 2]
│ │ └─very/                 [0, 1, 2]
│ │   └─deep/               [0, 1, 3]
│ │     └─folder/           [0, 1, 4]
│ │       └─very_deep_file  [0, 1, 5]
│ └─less_deep_file          [0, 1]
└─index.rst                 [0]
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>incomplete</code></strong> :&ensp;<code>list-like</code></dt>
<dd>List of integers denoting the depth of incomplete folders at the time
of constructing the line for a given item.
Zero represents being
inside the main folder, with increasing integers meaing increasing
depth.</dd>
<dt><strong><code>extend</code></strong> :&ensp;<code>str</code></dt>
<dd>Characters symbolizing the extension of a folder.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>str</code></dt>
<dd>Characters providing the gap between items and earlier parents.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Base header string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_base_header(self, incomplete, extend, space):
    &#39;&#39;&#39;
    For folder structures, generate the combination of extend and space
    tokens to prepend to file names when generating folder diagrams.


    The string generated here will still be missing the branch token
    (split or final) as well as any folderstart or filestart tokens.
    They are added within seedir.seedir().

    For any item included in a folder diagram, the combination of
    extend and space tokens is based on the depth of the item as well as the
    parent folders to that item which are not completed.  This information
    is symbolized with the `incomplete` argument.  The following illustrates
    the incomplete arguments passed to this function for an example folder
    tree:

    ```
    doc/
    ├─_static/                  [0]
    │ ├─embedded/               [0, 1]
    │ │ ├─deep_file             [0, 1, 2]
    │ │ └─very/                 [0, 1, 2]
    │ │   └─deep/               [0, 1, 3]
    │ │     └─folder/           [0, 1, 4]
    │ │       └─very_deep_file  [0, 1, 5]
    │ └─less_deep_file          [0, 1]
    └─index.rst                 [0]
    ```

    Parameters
    ----------
    incomplete : list-like
        List of integers denoting the depth of incomplete folders at the time
        of constructing the line for a given item.  Zero represents being
        inside the main folder, with increasing integers meaing increasing
        depth.
    extend : str
        Characters symbolizing the extension of a folder.
    space : str
        Characters providing the gap between items and earlier parents.

    Returns
    -------
    str
        Base header string.

    &#39;&#39;&#39;
    base_header = []
    max_i = max(incomplete)
    for p in range(max_i):
        if p in incomplete:
            base_header.append(extend)
        else:
            base_header.append(space)
    return &#34;&#34;.join(base_header)</code></pre>
</details>
</dd>
<dt id="seedir.folderstructure.FolderStructure.sort_dir"><code class="name flex">
<span>def <span class="ident">sort_dir</span></span>(<span>self, items, first=None, sort_reverse=False, sort_key=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sorting function used to sort contents when producing folder diagrams.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of folder contents.</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>'files'</code> or <code>'folders'</code>, optional</dt>
<dd>Sort either files or folders first. The default is None.</dd>
<dt><strong><code>sort_reverse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Reverse the sort applied. The default is False.</dd>
<dt><strong><code>sort_key</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function to apply to sort the objs by their basename.
The function
should take a single argument, of the type expected by
this FolderStucture.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Sorted input as a list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_dir(self, items, first=None, sort_reverse=False, sort_key=None):
    &#39;&#39;&#39;
    Sorting function used to sort contents when producing folder diagrams.

    Parameters
    ----------
    items : list-like
        Collection of folder contents.
    first : &#39;files&#39; or &#39;folders&#39;, optional
        Sort either files or folders first. The default is None.
    sort_reverse : bool, optional
        Reverse the sort applied. The default is False.
    sort_key : function, optional
        Function to apply to sort the objs by their basename.  The function
        should take a single argument, of the type expected by
        this FolderStucture.

    Returns
    -------
    list
        Sorted input as a list.

    &#39;&#39;&#39;
    if sort_key is None:
        key = lambda x : self.getname(x)
    else:
        key = lambda x: sort_key(self.getname(x))

    if first in [&#39;folders&#39;, &#39;files&#39;]:
        folders = [p for p in items if self.isdir(p)]
        files = [p for p in items if not self.isdir(p)]
        folders = natsort.natsorted(folders, reverse=sort_reverse, key=key)
        files = natsort.natsorted(files, reverse=sort_reverse, key=key)
        output = folders + files if first == &#39;folders&#39; else files + folders
    elif first is None:
        output = list(natsort.natsorted(items, reverse=sort_reverse, key=key))
    else:
        raise ValueError(&#34;`first` must be &#39;folders&#39;, &#39;files&#39;, or None.&#34;)

    return output</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="seedir" href="index.html">seedir</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="seedir.folderstructure.FakeDirStructure" href="#seedir.folderstructure.FakeDirStructure">FakeDirStructure</a></code></li>
<li><code><a title="seedir.folderstructure.PathlibStructure" href="#seedir.folderstructure.PathlibStructure">PathlibStructure</a></code></li>
<li><code><a title="seedir.folderstructure.RealDirStructure" href="#seedir.folderstructure.RealDirStructure">RealDirStructure</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="seedir.folderstructure.formatter_update_args" href="#seedir.folderstructure.formatter_update_args">formatter_update_args</a></code></li>
<li><code><a title="seedir.folderstructure.listdir_fullpath" href="#seedir.folderstructure.listdir_fullpath">listdir_fullpath</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="seedir.folderstructure.FolderStructure" href="#seedir.folderstructure.FolderStructure">FolderStructure</a></code></h4>
<ul class="two-column">
<li><code><a title="seedir.folderstructure.FolderStructure.beyond_depth_str" href="#seedir.folderstructure.FolderStructure.beyond_depth_str">beyond_depth_str</a></code></li>
<li><code><a title="seedir.folderstructure.FolderStructure.count_files" href="#seedir.folderstructure.FolderStructure.count_files">count_files</a></code></li>
<li><code><a title="seedir.folderstructure.FolderStructure.count_folders" href="#seedir.folderstructure.FolderStructure.count_folders">count_folders</a></code></li>
<li><code><a title="seedir.folderstructure.FolderStructure.filter_items" href="#seedir.folderstructure.FolderStructure.filter_items">filter_items</a></code></li>
<li><code><a title="seedir.folderstructure.FolderStructure.get_base_header" href="#seedir.folderstructure.FolderStructure.get_base_header">get_base_header</a></code></li>
<li><code><a title="seedir.folderstructure.FolderStructure.sort_dir" href="#seedir.folderstructure.FolderStructure.sort_dir">sort_dir</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>