<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>seedir.fakedir API documentation</title>
<meta name="description" content="Code for creating and editing &#34;fake directories&#34; within the `seedir` package;
i.e. Python folder tree objects.
This module can be used
to make …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.15em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>seedir.fakedir</code></h1>
</header>
<section id="section-intro">
<p>Code for creating and editing "fake directories" within the <code><a title="seedir" href="index.html">seedir</a></code> package;
i.e. Python folder tree objects.
This module can be used
to make example folder tree diagrams, read folder tree strings, or convert
abstract folder trees into real directories on a computer.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Code for creating and editing &#34;fake directories&#34; within the `seedir` package;
i.e. Python folder tree objects.  This module can be used
to make example folder tree diagrams, read folder tree strings, or convert
abstract folder trees into real directories on a computer.
&#34;&#34;&#34;

__pdoc__ = {&#39;get_random_int&#39;: False,
            &#39;recursive_add_fakes&#39;: False}

import os
import string
import re

import random

from seedir.errors import FakedirError
from seedir.folderstructure import FakeDirStructure, RealDirStructure
from seedir.folderstructure import listdir_fullpath

from seedir.printing import words

class FakeItem:
    &#39;&#39;&#39;Parent class for representing fake folders and files.&#39;&#39;&#39;
    def __init__(self, name, parent=None):
        &#39;&#39;&#39;
        Initialize the fake diretory or file object.

        Parameters
        ----------
        name : str
            Name for the folder or file.
        parent : seedir.fakedir.FakeDir or None, optional
            Parent of `self`. The default is `None`, meaning the object will
            be the &#34;root&#34; of the directory.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.name = name
        self._parent = None
        self.parent = parent
        self.depth = 0
        self.set_depth()

    @property
    def parent(self):
        &#39;&#39;&#39;
        Getter for the `parent` attribute.

        Returns
        -------
        seedir.fakedir.FakeDir
            The parent folder of the object.

        &#39;&#39;&#39;
        return self._parent

    @parent.setter
    def parent(self, other):
        &#39;&#39;&#39;
        Setter for the `parent` attribute.

        When a new parent is assigned for an object, this method
        verifies that the other object is `seedir.fakedir.FakeDir`, and that the other
        objects children do not contain a fake item with the same name.

        If those conditions are met, `self` is removed from the children
        of its current parent, and its parent attribute is reassigned.
        Depths are also reset.

        Parameters
        ----------
        other : seedir.fakedir.FakeDir
            Fake directory to become the new `parent` for self.

        Raises
        ------
        TypeError
            other is not a `seedir.fakedir.Fakedir`.

        FakedirError
            Name collision: `self.name` is in the child names of other.


        Returns
        -------
        None.

        &#39;&#39;&#39;
        if other:
            if not isinstance(other, FakeDir):
                raise TypeError(&#39;other parameter must be instance of FakeDir&#39;)
            if self.name in other.get_child_names():
                raise FakedirError(&#39;FakeDirs must have unique file/folder names&#39;)
            other._children.append(self)
        if self.parent is not None:
            self.parent._children.remove(self)
        self._parent = other
        self.set_depth()
        if isinstance(self, FakeDir):
            self.set_child_depths()

    def get_path(self):
        &#39;&#39;&#39;Return a &#34;path&#34; string of self, from the head `seedir.fakedir.FakeDir`
        (which has `parent == None`).

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; f = sd.randomdir(seed=5) # create a random FakeDir
        &gt;&gt;&gt; f
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; x = sd.FakeDir(&#39;newfolder&#39;, parent=f[&#39;zag/stein&#39;])
        &gt;&gt;&gt; x.get_path()
        &#39;MyFakeDir/zag/stein/newfolder&#39;

        ```

        &#39;&#39;&#39;
        parents = [self.name]
        on = self
        while on.parent is not None:
            on = on.parent
            parents.append(on.name)
        return &#39;/&#39;.join(parents[::-1])

    def set_depth(self):
        &#39;&#39;&#39;Set the depth attribute of `self`, based on the depth of parent.
        Automatically called when setting new parents.&#39;&#39;&#39;
        if self.parent is None:
            self.depth = 0
        else:
            self.depth = self.parent.depth + 1

    def isfile(self):
        &#34;&#34;&#34;Returns `True` if instance is a `seedir.fakedir.FakeFile` object&#34;&#34;&#34;
        return isinstance(self, FakeFile)

    def isdir(self):
        &#34;&#34;&#34;Returns True if instance is a `seedir.fakedir.FakeDir` object&#34;&#34;&#34;
        return isinstance(self, FakeDir)

    def siblings(self):
        &#34;&#34;&#34;Returns all the other children of `self.parent`.&#34;&#34;&#34;
        if self.parent is None:
            return []
        else:
            return [f for f in self.parent.listdir() if f is not self]

class FakeFile(FakeItem):
    &#39;&#39;&#39;Class to represent files in `seedir.fakedir.FakeDir` objects.

    Files in a `seedir.fakedir.FakeDir` have this type.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; f = sd.randomdir(seed=5) # create a random FakeDir
    &gt;&gt;&gt; f
    MyFakeDir/
    ├─senor.txt
    ├─verb.txt
    ├─takeoff.txt
    ├─monastic/
    │ ├─paddy.txt
    │ ├─ewe.txt
    │ ├─advantage.txt
    │ ├─hooves/
    │ └─registrar/
    └─zag/
      ├─thematic.txt
      ├─inelastic.txt
      ├─fierce.txt
      ├─gout/
      └─stein/
        ├─vector.txt
        ├─sora.txt
        └─proviso.txt

    &gt;&gt;&gt; f[&#39;senor.txt&#39;]
    FakeFile(MyFakeDir/senor.txt)

    ```

    &#39;&#39;&#39;
    def __init__(self, name, parent=None):
        &#39;&#39;&#39;Same as `seedir.fakedir.FakeItem` initialization, but adds
        `filename` and `extension` attributes.
        &#39;&#39;&#39;
        super().__init__(name, parent)
        self.filename, self.extension = os.path.splitext(self.name)

    def __str__(self):
        return &#39;FakeFile({})&#39;.format(self.get_path())

    def __repr__(self):
        return &#39;FakeFile({})&#39;.format(self.get_path())

class FakeDir(FakeItem):
    &#39;&#39;&#39;Class to represent fake folders.  Can be used to create
    custom folder tree diagrams.  See `seedir.fakedir.fakedir()` for converting
    a real directory into a FakeDir, `seedir.fakedir.fakedir_fromstring()` for
    converting a text folder diagram into a `FakeDir`, and `seedir.fakedir.randomdir()`
    for creating a random one.

    To make a `FakeDir` from scratch, use this class:

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; x = sd.FakeDir(&#39;myfakedir&#39;)
    &gt;&gt;&gt; x.seedir()
    myfakedir/

    ```

    There are various ways to add to it:

    ```
    # using methods; the created items are returned
    &gt;&gt;&gt; x.create_file([&#39;__init__.py&#39;, &#39;main.py&#39;, &#39;styles.txt&#39;])
    [FakeFile(myfakedir/__init__.py), FakeFile(myfakedir/main.py), FakeFile(myfakedir/styles.txt)]
    &gt;&gt;&gt; x.create_folder(&#39;docs&#39;)
    docs/

    # initializing new objects and setting the parent
    &gt;&gt;&gt; y = sd.FakeDir(&#39;resources&#39;, parent=x)

    # changing the parent of existing objects
    &gt;&gt;&gt; z = sd.FakeDir(&#39;images&#39;)
    &gt;&gt;&gt; z.parent = y

    &gt;&gt;&gt; for n in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]:
    ...     z.create_file(n + &#39;.png&#39;)
    FakeFile(myfakedir/resources/images/a.png)
    FakeFile(myfakedir/resources/images/b.png)
    FakeFile(myfakedir/resources/images/c.png)

    &gt;&gt;&gt; x.seedir(sort=True, first=&#39;folders&#39;)
    myfakedir/
    ├─docs/
    ├─resources/
    │ └─images/
    │   ├─a.png
    │   ├─b.png
    │   └─c.png
    ├─__init__.py
    ├─main.py
    └─styles.txt

    ```

    You can index with path-like strings:

    ```
    &gt;&gt;&gt; x[&#39;resources/images/a.png&#39;]
    FakeFile(myfakedir/resources/images/a.png)

    ```

    &#39;&#39;&#39;
    def __init__(self, name, parent=None):
        &#39;&#39;&#39;Same as `seedir.fakedir.FakeItem` initialization, but adds
        the `_children` attribute for keeping track of items inside the fake dir.
        &#39;&#39;&#39;
        # alter children through FakeDir methods!
        self._children = []
        super().__init__(name, parent)

    def __str__(self):
        &#39;&#39;&#39;String conversion of `FakeDir`&#39;&#39;&#39;
        return &#39;FakeDir({})&#39;.format(self.get_path())

    def __repr__(self):
        &#39;&#39;&#39;Representation of `FakeDir` (shown as a folder diagram).&#39;&#39;&#39;
        return self.seedir(printout=False)

    def __getitem__(self, path):
        &#34;&#34;&#34;Use path-like strings to index `FakeDir` objects.&#34;&#34;&#34;
        if not isinstance(path, str):
            raise TypeError(&#34;Can only index FakeDir with int or str, &#34;
                            &#34;not {}&#34;.format(type(path)))
        paths = path.split(&#39;/&#39;)
        current = self
        for p in paths:
            for f in current._children:
                if p == f.name:
                    current = f
                    break
            else:
                raise(FakedirError(&#39;Path &#34;{}&#34; not found through {}&#39;.format(path, self)))
        return current

    def create_folder(self, name):
        &#34;&#34;&#34;
        Create a new folder (`seedir.fakedir.FakeDir`) as a child.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; x = sd.FakeDir(&#39;Test&#39;)
        &gt;&gt;&gt; x.create_folder(&#34;new_folder&#34;)
        new_folder/
        &gt;&gt;&gt; x.seedir()
        Test/
        └─new_folder/

        ```

        Parameters
        ----------
        name : str
            Name of the new folder.  Can also be a collection of names to create
            multiple folders.

        Returns
        -------
        FakeDir or list
            The new object or objects (as a list) are returned.

        &#34;&#34;&#34;
        if isinstance(name, str):
            return FakeDir(name, parent=self)
        else:
            return [FakeDir(s, parent=self) for s in name]

    def create_file(self, name):
        &#34;&#34;&#34;
        Create a new file (`seedir.fakedir.FakeFile`) as a child.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; x = sd.FakeDir(&#39;Test&#39;)
        &gt;&gt;&gt; x.create_file(&#34;new_file.txt&#34;)
        FakeFile(Test/new_file.txt)
        &gt;&gt;&gt; x.seedir()
        Test/
        └─new_file.txt

        ```

        Parameters
        ----------
        name : str
            Name of the new file.  Can also be a collection of names to create
            multiple files.

        Returns
        -------
        FakeFile or list
            The new object or objects (as a list) are returned.

        &#34;&#34;&#34;
        if isinstance(name, str):
            return FakeFile(name, parent=self)
        else:
            return [FakeFile(s, parent=self) for s in name]

    def copy(self):
        &#39;&#39;&#39;
        Generate a totally unlinked copy object.  The root of the new FakeDir
        will be a copy of this folder (and all its subfolders).  Calling this
        method does not alter self at all.

        Returns
        -------
        seedir.fakedir.FakeDir
            A copy FakeDir.

        &#39;&#39;&#39;
        def recurse_build(f, other):
            &#39;&#39;&#39;Recursive helper for building the new copy.&#39;&#39;&#39;
            if f.isfile():
                new = FakeFile(name=f.name, parent=other)
            elif f.isdir():
                new = FakeDir(name=f.name, parent=other)
                for child in f.listdir():
                    recurse_build(child, other=new)
            return new

        return recurse_build(self, other=None)


    def delete(self, child):
        &#39;&#39;&#39;
        Delete items from a `seedir.fakedir.FakeDir`.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=5)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; r[&#39;zag&#39;].delete([&#39;thematic.txt&#39;, &#39;inelastic.txt&#39;]) # delete with string names
        &gt;&gt;&gt; r.delete(r[&#39;monastic&#39;]) # delete with objects
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        └─zag/
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        ```

        Parameters
        ----------
        child : str, FakeDir, FakeFile or list-like
            Child or children to remove.  Can be a string name, actual
            `seedir.fakedir.FakeDir` / `seedir.fakedir.FakeFile` object,
            or a collection of names or items.

        Raises
        ------
        FakedirError
            No item found to delete.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        target = None
        if type(child) in [FakeDir, FakeFile]:
            target = child.name
        elif isinstance(child, str):
            target = child
        if target is not None:
            try:
                to_del = next(f for f in self._children if f.name == target)
                to_del.parent = None
            except StopIteration:
                raise FakedirError(&#39;{} has no child with name &#34;{}&#34;&#39;.format(self, target))
        else:
            child_copy = [c for c in child]
            for c in child_copy:
                target = None
                if type(c) in [FakeDir, FakeFile]:
                    target = c.name
                elif isinstance(c, str):
                    target = c
                if target is not None:
                    try:
                        to_del = next(f for f in self._children if
                                      f.name == target)
                        to_del.parent = None
                    except StopIteration:
                        raise FakedirError(&#39;{} has no child with name &#34;{}&#34;&#39;.format(self, target))

    def get_child_names(self):
        &#39;&#39;&#39;Return a list of child names.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=5)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; r.get_child_names()
        [&#39;senor.txt&#39;, &#39;verb.txt&#39;, &#39;takeoff.txt&#39;, &#39;monastic&#39;, &#39;zag&#39;]

        ```

        &#39;&#39;&#39;
        return [c.name for c in self._children]

    def listdir(self):
        &#39;&#39;&#39;Return the list of `seedir.fakedir.FakeFile` and `seedir.fakedir.FakeDir`
        objects that are children of `self` (like `os.listdir`).

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=1)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─churchmen.txt
        └─exposure/

        &gt;&gt;&gt; print([str(i) for i in r.listdir()])
        [&#39;FakeFile(MyFakeDir/churchmen.txt)&#39;, &#39;FakeDir(MyFakeDir/exposure)&#39;]

        ```
        &#39;&#39;&#39;
        return self._children

    def realize(self, path=None):
        &#39;&#39;&#39;
        Convert a fake file tree into a real one by creating a folder at a
        given path, and populating it with files and sub-directories.

        All files will be empty.

        ```
        import os

        import seedir as sd

        r = sd.randomdir(seed=1)
        # MyFakeDir/
        # ├─churchmen.txt
        # └─exposure/

        r.realize()
        os.path.isdir(&#39;MyFakeDir/exposure&#39;)
        # True
        ```

        Parameters
        ----------
        path : str, optional
            System path where to create the folder. The default is `None`,
            in which the current working directory is used.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        def create(f, root):
            fpath = f.get_path()
            joined = os.path.join(root, fpath)
            if isinstance(f, FakeDir):
                os.mkdir(joined)
            elif isinstance(f, FakeFile):
                with open(joined, &#39;w&#39;): pass;
        if path is None:
            path = os.getcwd()
        self.walk_apply(create, root=path)

    def seedir(self, style=&#39;lines&#39;, printout=True, indent=2, uniform=None,
               anystart=None, anyend=None, depthlimit=None, itemlimit=None,
               beyond=None, first=None, sort=False, sort_reverse=False, sort_key=None,
               include_folders=None, exclude_folders=None, include_files=None,
               exclude_files=None, regex=False, slash=&#39;/&#39;, mask=None,
               formatter=None, sticky_formatter=False, **kwargs):
        &#39;&#39;&#39;

        Create a folder tree diagram for `self`.  `seedir.fakedir.FakeDir` version of
        `seedir.realdir.seedir()` (see its documentation for examples).

        Parameters
        ----------
        style : &#39;lines&#39;, &#39;dash&#39;, &#39;arrow&#39;, &#39;spaces&#39;, &#39;plus&#39;, or &#39;emoji&#39;, optional
            Style to use. The default is `&#39;lines&#39;`.  A style determines the set
            of characters (&#34;tokens&#34;) used to represent the base structure of
            the directory (e.g. which items belong to which folders, when items
            are the last member of a folder, etc.).  The actual tokens being used
            by each style can be viewed with `seedir.printing.get_styleargs()`.
        printout : bool, optional
            Print the folder structure in the console. The default is `True`.  When
            `False`, the folder diagram is returned as a string.
        indent : int (&gt;= 0), optional
            Number of spaces separating items from their parent folder.
            The default is `2`.
        uniform : str or None, optional
            Characters to use for all tokens when creating the tree diagram.
            The default is `None`.  When not `None`, the extend, space, split, and
            final tokens are replaced with `uniform` (the `&#39;spaces&#39;` style is
            essentially `uniform = &#39;  &#39;`).
        anystart : str or None, optional
            Characters to append before any item (i.e. folder or file).  The
            default is `None`.  Specific starts for folders and files can be
            specified (see `**kwargs`).
        anyend : str or None, optional
            Characters to append after any item (i.e. folder or file).  The
            default is `None`.  Specific ends for folders and files can be
            specified (see `**kwargs`).
        depthlimit : int or None, optional
            Limit the depth of folders to traverse.  Folders at the `depthlimit` are
            included, but their contents are not shown (with the exception of the
            beyond parameter being specified).  The default is `None`, which can
            cause exceptionally long runtimes for deep or extensive directories.
        itemlimit : int or None, optional
            Limit the number of items in a directory to show.  Items beyond the
            `itemlimit` can be expressed using the `beyond` parameter.  The files and
            folders left out are determined by the sorting parameters
            (`sort`, `sort_reverse`, `sort_key`).  The default is `None`.
        beyond : str (&#39;ellipsis&#39;, &#39;content&#39; or a string starting with an underscore) or None, optional
            String to indicate directory contents beyond the `itemlimit` or the
            `depthlimit`.  The default is `None`.  Options are: `&#39;ellipsis&#39;` (`&#39;...&#39;`),
            `&#39;content&#39;` or `&#39;contents&#39;` (the number of files and folders beyond), or
            a string starting with `&#39;_&#39;` (everything after the leading underscore
            will be returned)
        first : &#39;files&#39;, &#39;folders&#39;, or None, optional
            Sort the directory so that either files or folders appear first.
            The default is `None`.
        sort : bool, optional
            Sort the directory. With no other specifications, the sort will be a
            simple alphabetical sort of the item names, but this can be altered
            with the `first`, `sort_reverse`, and `sort_key parameters`.
            The default is `False`.
        sort_reverse : bool, optional
            Reverse the sorting determined by `sort` or `sort_key`.
            The default is `False`.
        sort_key : function, optional
            Key to use for sorting file or folder names, akin to the `key` parameter
            of the builtin `sorted()` or `list.sort()`. The function should take a
            string as an argument. The default is `None`.
        include_folders, exclude_folders, include_files, exclude_files : str, list-like, or None, optional
            Folder / file names to include or exclude. The default is `None`.  By
            default, these are interpreted literally.  Pass `regex=True` for
            using regular expressions.
        regex : bool, optional
            Interpret the strings of include/exclude file/folder arguments as
            regular expressions. The default is `False`.
        mask : function, optional
            Function for filtering items.  Each individual item object
            is passed to the mask function.  If `True` is returned, the
            item is kept.  The default is `None`.
        formatter : function, optional
            Function for customizing the directory printing logic and style
            based on specific folders &amp; files.  When passed, the formatter
            is called on each item in the file tree, and the current arguments
            are updated based what is returned.

            The formatter function should accept a FakeItem as a
            single argument (either relative or absolute, depending on what is passed
            to the `path` argument), and it should return either a dictionary or None.
            The dictionary should have names of arguments as keys and their respective
            setting as values.

            The following options can meaningfully be toggled by passing a formatter
            function: `depthlimit`, `itemlimit`, `beyond`, `first`, `sort`, `sort_reverse`,
            `sort_key`, `include_folders`, `regex`, `mask`, as well as any seedir token
            keywords (`extend`, `space`, `split`, `final`, `folderstart`, `filestart`,
            `folderend`, `fileend`).

            Note that in version 0.3.0, formatter could only be used to update
            the style tokens.  It can now be used to udpate those as well as the other
            arguments listed above.

            If None is returned by formatter, the tokens will be set by `style`.

            Note that items exlcuded by the inclusion/exclusion arguments (or the
            `mask`) *will not* be seen by formatter.  Similarly, any folder tree
            entries created by the `beyond` argument *will not* be seen by formatter.

        sticky_formatter : bool, optional
            When True, updates to argumnts made by the `formatter` (see above)
            will be permanent.  Thus, if arguments are updated when the `formatter`
            is called on a folder, its children will (recursively) inherit
            those new arguments.
        slash : str, option:
            **`DeprecationWarning`**: *With addition of `folderend` in v0.3.1,
            `slash` is to be deprecated in a future version.*

            Slash character to follow folders.  If `&#39;sep&#39;`, uses `os.sep`.  The
            default is `&#39;/&#39;`.
        **kwargs : str
            Specific tokens to use for creating the file tree diagram.  The tokens
            use by each builtin style can be seen with `seedir.printing.get_styleargs()`.
            Valid options are `extend` (characters to show the extension of a directory
            while its children are traversed), `space` (character to provide the
            correct indentation of an item when some of its parent / grandparent
            directories are completely traversed), `split` (characters to show a
            folder or file within a directory, with more items following),
            `final` (characters to show a folder or file within a directory,
            with no more items following), `folderstart` (characters to prepend
            before any folder), `filestart` (characters to preppend before any
            file), `folderend` (characters to append after any folder), and
            `fileend` (characters to append after any file). The following shows
            the default tokens for the `&#39;lines&#39;` style:

                &gt;&gt;&gt; import seedir as sd
                &gt;&gt;&gt; sd.get_styleargs(&#39;lines&#39;)
                {&#39;split&#39;: &#39;├─&#39;, &#39;extend&#39;: &#39;│ &#39;, &#39;space&#39;: &#39;  &#39;, &#39;final&#39;: &#39;└─&#39;, &#39;folderstart&#39;: &#39;&#39;, &#39;filestart&#39;: &#39;&#39;, &#39;folderend&#39;: &#39;/&#39;, &#39;fileend&#39;: &#39;&#39;}

            All default style tokens are 2 character strings, except for
            the file/folder start/end tokens.  Style tokens from `**kwargs` are not
            affected by the indent parameter.  The `uniform`, `anystart`, and
            `anyend` parameters can be used to affect multiple style tokens.

        Returns
        -------
        s (str) or None
            The tree diagram (as a string) or None if prinout = True, in which
            case the tree diagram is printed in the console.

        &#39;&#39;&#39;

        # call
        args = dict(style=style,
                    printout=printout,
                    indent=indent,
                    uniform=uniform,
                    anystart=anystart,
                    anyend=anyend,
                    depthlimit=depthlimit,
                    itemlimit=itemlimit,
                    beyond=beyond,
                    first=first,
                    sort=sort,
                    sort_reverse=sort_reverse,
                    sort_key=sort_key,
                    include_folders=include_folders,
                    exclude_folders=exclude_folders,
                    include_files=include_files,
                    exclude_files=exclude_files,
                    regex=regex,
                    mask=mask,
                    formatter=formatter,
                    sticky_formatter=sticky_formatter,
                    **kwargs)

        return FakeDirStructure(self, **args)

    def set_child_depths(self):
        &#39;&#39;&#39;Recursively set depths of `self` and its children.
        Called automatically when a new `parent` is assigned.&#39;&#39;&#39;
        def apply_setdepth(FD):
            FD.set_depth()
        self.walk_apply(apply_setdepth)

    def trim(self, depthlimit):
        &#34;&#34;&#34;
        Remove items beyond the `depthlimit`.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=456)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─Vogel.txt
        ├─monkish.txt
        ├─jowly.txt
        ├─scrooge/
        │ ├─light.txt
        │ ├─reliquary.txt
        │ ├─sandal/
        │ ├─paycheck/
        │ │ ├─electrophoresis.txt
        │ │ └─Pyongyang/
        │ └─patrimonial/
        ├─Uganda/
        └─pedantic/
          └─cataclysmic.txt

        &gt;&gt;&gt; r.trim(1)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─Vogel.txt
        ├─monkish.txt
        ├─jowly.txt
        ├─scrooge/
        ├─Uganda/
        └─pedantic/

        ```


        Parameters
        ----------
        depthlimit : non-negative int
            Files beyond this depth will be cut. The root has depth `0`.

        Raises
        ------
        ValueError
            `depthlimit` is not a non-negative int

        Returns
        -------
        None.

        &#34;&#34;&#34;
        depthlimit = int(depthlimit)
        if depthlimit &lt; 0:
            raise ValueError(&#39;depthlimit must be non-negative int&#39;)
        depthlimit += self.depth
        def trim_apply(f, depthlimit):
            if depthlimit is not None and f.depth == depthlimit:
                if isinstance(f, FakeDir):
                    f.delete(f.listdir())
        if depthlimit == self.depth:
            self.delete(self.listdir())
        else:
            self.walk_apply(trim_apply, depthlimit=depthlimit)

    def walk_apply(self, foo, *args, **kwargs):
        &#34;&#34;&#34;
        Recursively apply a function the children of self (and so on)

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=5)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; def replace_txt(f):
        ...    f.name = f.name.replace(&#39;txt&#39;, &#39;pdf&#39;)

        &gt;&gt;&gt; r.walk_apply(replace_txt)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.pdf
        ├─verb.pdf
        ├─takeoff.pdf
        ├─monastic/
        │ ├─paddy.pdf
        │ ├─ewe.pdf
        │ ├─advantage.pdf
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.pdf
          ├─inelastic.pdf
          ├─fierce.pdf
          ├─gout/
          └─stein/
            ├─vector.pdf
            ├─sora.pdf
            └─proviso.pdf

        ```

        Parameters
        ----------
        foo : function
            Function to apply.
        *args :
            Additional positional arguments for `foo`.
        **kwargs :
            Additional keyword arguments for `foo`.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        foo(self, *args, **kwargs)
        for f in self._children:
            if isinstance(f, FakeDir):
                f.walk_apply(foo, *args, **kwargs)
            else:
                foo(f, *args, **kwargs)

def get_random_int(collection, seed=None):
    &#39;&#39;&#39;
    Helper function for selecting a random integer, used by seedir.populate().

    Parameters
    ----------
    collection : list-like
        Collection of integers to select from.
    seed : int or float, optional
        Random seed. The default is None.

    Raises
    ------
    TypeError
        Non-integer found.

    Returns
    -------
    r : int
        Randomly chosen int from collection.

    &#39;&#39;&#39;
    r = random.Random(seed).choice(collection)
    if not isinstance(r, int):
        raise TypeError(&#39;non int found&#39;)
    return r

def populate(fakedir, depth=3, folders=2, files=2, stopchance=.5, seed=None,
             extensions=[&#39;txt&#39;]):
    &#39;&#39;&#39;
    Function for populating `seedir.fakedir.FakeDir` objects with random files and folders.
    Used by `seedir.fakedir.randomdir()`.  Random dictionary names are chosen
    for file and folder names.

    Parameters
    ----------
    fakedir : seedir.fakedir.FakeDir
        Fake directory to populate.
    depth : int, optional
        Maximum depth to create folders and files. The default is `3`.
    folders : int or collection of integers, optional
        Parameter for setting the number of folders per directory.
        The default is `2`.  If `int`, represents the number of folders
        per directory.  If collection of integers, a random value will be
        chosen from the collection each time a directory is popualted.
    files : int or collection of integers, optional, optional
        Same as the folders parameter, but for files.
    stopchance : float between 0 and 1, optional
        Chance that an added folder will not be populated. The default is `.5`.
    seed : int or float, optional
        Random seed. The default is `None`.
    extensions : list-likie, optional
        Collection of extensions to randomly select from for files.  The
        default is `[&#39;txt&#39;]`.  Leading period can be included or omitted.

    Raises
    ------
    ValueError
        Issue selecting int from folders or files.

    Returns
    -------
    None, input is modified in place.

    &#39;&#39;&#39;
    random.seed(seed)
    if not isinstance(folders, int):
        try:
            fold_num = get_random_int(folders, seed=seed)
        except:
            raise ValueError(&#39;folders must be an int or collection of int&#39;)
    else:
        fold_num = folders
    if not isinstance(files, int):
        try:
            file_num = get_random_int(files, seed=seed)
        except:
            raise ValueError(&#39;files must be an int or collection of int&#39;)
    else:
        file_num = files
    for i in range(file_num):
        name = random.choice(words) + random.choice(extensions)
        while name in [f.name for f in fakedir._children]:
            name = random.choice(words) + random.choice(extensions)
        fakedir.create_file(name)
    for i in range(fold_num):
        name = random.choice(words)
        while name in [f.name for f in fakedir._children]:
            name = random.choice(words)
        fakedir.create_folder(name)
    for f in fakedir._children:
        if isinstance(f, FakeDir):
            if f.depth &lt;= depth and random.uniform(0, 1) &gt; stopchance:
                if seed is not None:
                    seed += random.random()
                populate(f, depth=depth, folders=folders, files=files,
                         seed=seed, stopchance=stopchance,
                         extensions=extensions)

def randomdir(depth=2, files=range(1,4), folders=range(0,4),
              stopchance=.5, seed=None, name=&#39;MyFakeDir&#39;, extensions=[&#39;txt&#39;]):
    &#39;&#39;&#39;
    Create a randomized `seedir.fakedir.FakeDir`, initialized with random
    dictionary words.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; sd.randomdir(seed=7)
    MyFakeDir/
    ├─Hardin.txt
    ├─Kathleen.txt
    ├─berserk/
    └─pineapple/
      ├─visceral.txt
      ├─gestural.txt
      ├─plenty.txt
      ├─discoid/
      │ ├─eclat.txt
      │ └─milord/
      ├─Offenbach/
      │ ├─Trianon.txt
      │ ├─Monday.txt
      │ ├─ditty.txt
      │ ├─peddle/
      │ ├─delta/
      │ └─irredentism/
      └─Perseus/
        ├─hothouse.txt
        ├─clock.txt
        ├─covetous/
        └─Ekstrom/

    ```

    Parameters
    ----------
    depth : int, optional
        Maximum depth to create folders and files. The default is `3`.
    folders : int or collection of integers, optional
        Parameter for setting the number of folders per directory.
        The default is `range(1,4)`.  If `int`, represents the number of folders
        per directory.  If collection of integers, a random value will be
        chosen from the collection each time a directory is popualted.
    files : int or collection of integers, optional, optional
        Same as the `folders` parameter, but for files.  The default
        is `range(0,4)`.
    stopchance : float between 0 and 1, optional
        Chance that an added folder will not be populated. The default is `.5`.
    seed : int or float, optional
        Random seed. The default is `None`.
    extensions : list-likie, optional
        Collection of extensions to randomly select from for files.  The
        default is `[&#39;txt&#39;]`.  Leading period can be included or omitted.

    Returns
    -------
    top : seedir.fakedir.FakeDir
        Fake directory.

    &#39;&#39;&#39;
    top = FakeDir(name)
    new_ex = []
    for x in extensions:
        if x[0] != &#39;.&#39;:
            new_ex.append(&#39;.&#39; + x)
        else:
            new_ex.append(x)
    populate(top, depth, folders, files, seed=seed, stopchance=stopchance,
             extensions=new_ex)
    return top

def recursive_add_fakes(path, parent, depth=0, depthlimit=None,
                        itemlimit=None, first=None, sort=False,
                        sort_reverse=False, sort_key=None,
                        include_folders=None, exclude_folders=None,
                        include_files=None, exclude_files=None,
                        mask=None, regex=False):
    &#39;&#39;&#39;
    Recursive helper function for seedir.fakedir(), for creating a
    fake folder tree from a real one.

    Parameters
    ----------
    path : str
        System path of a folder.
    parent : seedir.fakedir.FakeDir
        Fake directory to add items to.
    depth : int, optional
        Tracker for depth of folders traversed. The default is 0.
    depthlimit : int, optional
        Limit on the depth of folders to traverse. The default is None.
    itemlimit : int, optional
        Limit on the number of items to include per directory.
        The default is None.
    first : &#39;folders&#39; or &#39;files&#39;, optional
        Sort to have folders or files appear first. The default is None.
    sort : bool, optional
        Apply a sort to items in each directory. The default is False.
    sort_reverse : bool, optional
        Reverse the sort. The default is False.
    sort_key : function, optional
        Key function for sorting item names. The default is None.
    include_folders, exclude_folders, include_files, exclude_files : str, list-like, or None, optional
            Folder / file names to include or exclude. The default is None.
    mask : function, optional
        Function for filtering items.  Absolute paths of each individual item
        are passed to the mask function.  If True is returned, the
        item is kept.  The default is None.
    regex : bool, optional
        Interpret include/exclude folder/file arguments as regular
        expressions. The default is False.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    if depthlimit is not None and depth &gt;= depthlimit:
        return
    depth +=1
    listdir = listdir_fullpath(path)
    if sort or first is not None:
        listdir = RealDirStructure.sort_dir(listdir, first=first,
                                            sort_reverse=sort_reverse, sort_key=sort_key)
    if any(arg is not None for arg in [
            include_folders,
            exclude_folders,
            include_files,
            exclude_files,
            mask]):
        listdir = RealDirStructure.filter_items(listdir,
                                                include_folders=include_folders,
                                                exclude_folders=exclude_folders,
                                                include_files=include_files,
                                                exclude_files=exclude_files,
                                                regex=regex,
                                                mask=mask)
    for i, f in enumerate(listdir):
        name = os.path.basename(f)
        if i == itemlimit:
            break
        if os.path.isdir(f):
            new = FakeDir(name=name, parent=parent)
            recursive_add_fakes(path=f, parent=new, depth=depth,
                                depthlimit=depthlimit,
                                itemlimit=itemlimit,
                                include_folders=include_folders,
                                exclude_folders=exclude_folders,
                                include_files=include_files,
                                exclude_files=exclude_files,
                                mask=mask, regex=regex)
        else:
            new = FakeFile(name=name, parent=parent)

def fakedir(path, depthlimit=None, itemlimit=None, first=None,
            sort=False, sort_reverse=False, sort_key=None,
            include_folders=None, exclude_folders=None, include_files=None,
            exclude_files=None, mask=None, regex=True):
    &#39;&#39;&#39;
    Function for creating a `seedir.fakedir.FakeDir` (representation of a directory)
    from a real system directory.  Rather than immediately representing
    a directory as a string (`seedir.realdir.seedir()`), this function can be used
    to create an editable representation of the directory, or to join one or
    more directories.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; f = sd.fakedir(&#39;.&#39;, depthlimit=0)
    &gt;&gt;&gt; type(f)
    &lt;class &#39;seedir.fakedir.FakeDir&#39;&gt;

    ```

    Parameters
    ----------
    path : str
        System path of a directory.
    depthlimit : int, optional
        Limit on the depth of directories to traverse. Folders at the depth
        limit will be included, but their contents will not be.
        The default is `None`.
    itemlimit : int, optional
        Limit on the number of items to include per directory.
        The default is `None`, meaning all items will be added.  The priority
        of items is determined by `os.listdir()`, unless sorting arguments
        are passed.
    first : &#39;folders&#39; or &#39;files&#39;, optional
        Sort to show folders or files first. The default is `None`.
    sort : bool, optional
        Apply a (name) sort on each directory. The default is `False`.
    sort_reverse : bool, optional
        Reverse the sort. The default is `False`.
    sort_key : function, optional
        Key function for sorting the file names. The default is `None`.
    include_folders, exclude_folders, include_files, exclude_files : str, list-like, or None, optional
            Folder / file names to include or exclude. The default is `None`.
    mask : function, optional
        Function for filtering items.  Absolute paths of each individual item
        are passed to the mask function.  If `True` is returned, the
        item is kept.  The default is `None`.
    regex : bool, optional
        Interpret include/exclude folder/file arguments as regular
        expressions. The default is `False`.

    Raises
    ------
    FakedirError
        path does not point to a directory.

    Returns
    -------
    output : seedir.fakedir.FakeDir
        Fake directory matching the path.

    &#39;&#39;&#39;
    if not os.path.isdir(path):
        raise FakedirError(&#39;path must be a directory&#39;)
    output = FakeDir(os.path.basename(path))
    recursive_add_fakes(path, parent=output, depthlimit=depthlimit,
                        itemlimit=itemlimit,
                        first=first,
                        sort=sort,
                        sort_reverse=sort_reverse,
                        sort_key=sort_key,
                        include_folders=include_folders,
                        exclude_folders=exclude_folders,
                        include_files=include_files,
                        exclude_files=exclude_files,
                        mask=mask, regex=regex)
    return output

def fakedir_fromstring(s, start_chars=None, name_chars=None,
                       header_regex=None, name_regex=None,
                       supername=&#39;FakeDir&#39;, parse_comments=True):
    &#39;&#39;&#39;
    Convert a string folder tree diagram into a `seedir.fakedir.FakeDir`.
    This can be used to read in external representations of folder structures,
    edit them, and recreate them in a new location.

    This function has mostly been tested with examples from Stack Overflow
    and other Python learning sites (as well as output from `seedir.realdir.seedir()`).
    There are surely cases which will causes errors or unexpected results.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; s = &#34;&#34;&#34;doc/
    ... ├─_static/
    ... │ ├─embedded/
    ... │ │ ├─deep_file
    ... │ │ └─very/
    ... │ │   └─deep/
    ... │ │     └─folder/
    ... │ │       └─very_deep_file
    ... │ └─less_deep_file
    ... ├─about.rst
    ... ├─conf.py
    ... └─index.rst&#34;&#34;&#34;

    &gt;&gt;&gt; f = sd.fakedir_fromstring(s) # now can be edited or restyled
    &gt;&gt;&gt; f.seedir(style=&#39;spaces&#39;)
    doc/
      _static/
        embedded/
          deep_file
          very/
            deep/
              folder/
                very_deep_file
        less_deep_file
      about.rst
      conf.py
      index.rst

    ```


    Parameters
    ----------
    s : str
        String representation a folder tree.
    start_chars : str, optional
        A string of characters which will be searched for as the start
        of a folder or file name. The default is `None`, in which case the
        characters are all letters, numbers, and punctuation marks except
        for `/:?&#34;*&lt;&gt;|` or `+=-`.
    name_chars : str, optional
        A string of characters which will be searched for as being part
        of a file or folder name. The default is `None`, in which case the
        characters are all letters, numbers, punctuation marks except
        for `/:?&#34;*&lt;&gt;|,` and spaces.
    header_regex : str, optional
        Regular expression to match the &#34;header&#34; of each line, i.e. the
        structural characters of the folder diagram.  The default is `None`.
        If passed, the `start_chars` argument will be ignored.  This and
        `name_regex` are intended to provide functionality for parsing
        specific or unusual cases.
    name_regex : str, optional
        Regular expression to match all the folder or file names.
        The default is `None`.
        If passed, the `start_chars` argument will be ignored.
    supername : str, optional
        Name to give the head directory if one cannot be found.
        The default is `&#39;FakeDir&#39;`.  This can happen when there is no clear
        head directory in the string.
    parse_comments : bool, optional
        Try to parse and remove Python comments (following `#`).
        The default is `True`.

    Returns
    -------
    seedir.fakedir.FakeDir
        Fake directory corresponding to the input string.

    &#39;&#39;&#39;
    slashes = [&#39;/&#39;, &#39;\\&#39;, os.sep]
    joinedslashes = &#39;&#39;.join(slashes)

    byline = s.split(&#39;\n&#39;)
    keyboard_chars = (string.ascii_letters + string.digits
                      + string.punctuation)
    filtered = &#34;&#34;.join([c for c in keyboard_chars if c not in &#39;/:?&#34;*&lt;&gt;|&#39;])
    if start_chars is None:
        start_chars = &#34;&#34;.join([c for c in filtered if c not in &#39;+=-&#39;])
    if name_chars is None:
        name_chars = filtered + &#39; &#39; + &#39;-&#39;

    names = []
    headers = []
    depths = []

    for line in byline:
        if not line:
            continue
        if header_regex is None:
            header = re.match(&#39;.*?(?=[{}])&#39;.format(start_chars), line)
        else:
            header = re.match(header_regex, line)
        if header is None:
            continue
        else:
            header = header.group()
        depth = len(header)
        if name_regex is None:
            name = re.match(&#39;[{}]*[/\\\\]*&#39;.format(name_chars), line[depth:])
        else:
            name = re.match(name_regex, line)
        if name is None:
            continue
        else:
            name = name.group()
        if &#39;#&#39; in name and parse_comments:
            name = re.match(&#39;.*?(?=#)&#39;, name).group().strip()
        if not name:
            continue

        headers.append(header)
        names.append(name)
        depths.append(depth)

    fakeitems = []
    superparent = None
    min_depth = min(depths)
    if len([d for d in depths if d == min_depth]) &gt; 1:
        superparent = FakeDir(supername)
    min_depth_index1 = depths.index(min_depth)
    if any(i &gt; min_depth for i in depths[:min_depth_index1]):
        superparent = FakeDir(supername)

    for i, name in enumerate(names):
        is_folder = False
        if name.strip()[-1] in slashes:
            is_folder = True
        if i &lt; len(names) - 1:
            if depths[i + 1] &gt; depths[i]:
                is_folder = True

        fmt_name = name.rstrip(joinedslashes)

        if depths[i] == min_depth:
            if is_folder:
                fakeitems.append(FakeDir(fmt_name, parent=superparent))
            else:
                fakeitems.append(FakeFile(fmt_name, parent=superparent))
        else:
            shallower = [d for d in depths[:i] if d &lt; depths[i]]
            if shallower:
                max_shallower = max([d for d in depths[:i] if d &lt; depths[i]])
                parent_index = max(idx for idx, val in enumerate(depths[:i])
                                   if val == max_shallower)
                parent = fakeitems[parent_index]
            else:
                parent = superparent
            if is_folder:
                fakeitems.append(FakeDir(fmt_name, parent=parent))
            else:
                fakeitems.append(FakeFile(fmt_name, parent=parent))

    if superparent is not None:
        return superparent
    else:
        idx = depths.index(min_depth)
        return fakeitems[idx]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="seedir.fakedir.fakedir"><code class="name flex">
<span>def <span class="ident">fakedir</span></span>(<span>path, depthlimit=None, itemlimit=None, first=None, sort=False, sort_reverse=False, sort_key=None, include_folders=None, exclude_folders=None, include_files=None, exclude_files=None, mask=None, regex=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for creating a <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> (representation of a directory)
from a real system directory.
Rather than immediately representing
a directory as a string (<code><a title="seedir.realdir.seedir" href="realdir.html#seedir.realdir.seedir">seedir()</a></code>), this function can be used
to create an editable representation of the directory, or to join one or
more directories.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; f = sd.fakedir('.', depthlimit=0)
&gt;&gt;&gt; type(f)
&lt;class 'seedir.fakedir.FakeDir'&gt;

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>System path of a directory.</dd>
<dt><strong><code>depthlimit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Limit on the depth of directories to traverse. Folders at the depth
limit will be included, but their contents will not be.
The default is <code>None</code>.</dd>
<dt><strong><code>itemlimit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Limit on the number of items to include per directory.
The default is <code>None</code>, meaning all items will be added.
The priority
of items is determined by <code>os.listdir()</code>, unless sorting arguments
are passed.</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>'folders'</code> or <code>'files'</code>, optional</dt>
<dd>Sort to show folders or files first. The default is <code>None</code>.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Apply a (name) sort on each directory. The default is <code>False</code>.</dd>
<dt><strong><code>sort_reverse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Reverse the sort. The default is <code>False</code>.</dd>
<dt><strong><code>sort_key</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Key function for sorting the file names. The default is <code>None</code>.</dd>
<dt><strong><code>include_folders</code></strong>, <strong><code>exclude_folders</code></strong>, <strong><code>include_files</code></strong>, <strong><code>exclude_files</code></strong> :&ensp;<code>str, list-like,</code> or <code>None</code>, optional</dt>
<dd>Folder / file names to include or exclude. The default is <code>None</code>.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function for filtering items.
Absolute paths of each individual item
are passed to the mask function.
If <code>True</code> is returned, the
item is kept.
The default is <code>None</code>.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Interpret include/exclude folder/file arguments as regular
expressions. The default is <code>False</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FakedirError</code></dt>
<dd>path does not point to a directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code></dt>
<dd>Fake directory matching the path.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fakedir(path, depthlimit=None, itemlimit=None, first=None,
            sort=False, sort_reverse=False, sort_key=None,
            include_folders=None, exclude_folders=None, include_files=None,
            exclude_files=None, mask=None, regex=True):
    &#39;&#39;&#39;
    Function for creating a `seedir.fakedir.FakeDir` (representation of a directory)
    from a real system directory.  Rather than immediately representing
    a directory as a string (`seedir.realdir.seedir()`), this function can be used
    to create an editable representation of the directory, or to join one or
    more directories.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; f = sd.fakedir(&#39;.&#39;, depthlimit=0)
    &gt;&gt;&gt; type(f)
    &lt;class &#39;seedir.fakedir.FakeDir&#39;&gt;

    ```

    Parameters
    ----------
    path : str
        System path of a directory.
    depthlimit : int, optional
        Limit on the depth of directories to traverse. Folders at the depth
        limit will be included, but their contents will not be.
        The default is `None`.
    itemlimit : int, optional
        Limit on the number of items to include per directory.
        The default is `None`, meaning all items will be added.  The priority
        of items is determined by `os.listdir()`, unless sorting arguments
        are passed.
    first : &#39;folders&#39; or &#39;files&#39;, optional
        Sort to show folders or files first. The default is `None`.
    sort : bool, optional
        Apply a (name) sort on each directory. The default is `False`.
    sort_reverse : bool, optional
        Reverse the sort. The default is `False`.
    sort_key : function, optional
        Key function for sorting the file names. The default is `None`.
    include_folders, exclude_folders, include_files, exclude_files : str, list-like, or None, optional
            Folder / file names to include or exclude. The default is `None`.
    mask : function, optional
        Function for filtering items.  Absolute paths of each individual item
        are passed to the mask function.  If `True` is returned, the
        item is kept.  The default is `None`.
    regex : bool, optional
        Interpret include/exclude folder/file arguments as regular
        expressions. The default is `False`.

    Raises
    ------
    FakedirError
        path does not point to a directory.

    Returns
    -------
    output : seedir.fakedir.FakeDir
        Fake directory matching the path.

    &#39;&#39;&#39;
    if not os.path.isdir(path):
        raise FakedirError(&#39;path must be a directory&#39;)
    output = FakeDir(os.path.basename(path))
    recursive_add_fakes(path, parent=output, depthlimit=depthlimit,
                        itemlimit=itemlimit,
                        first=first,
                        sort=sort,
                        sort_reverse=sort_reverse,
                        sort_key=sort_key,
                        include_folders=include_folders,
                        exclude_folders=exclude_folders,
                        include_files=include_files,
                        exclude_files=exclude_files,
                        mask=mask, regex=regex)
    return output</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.fakedir_fromstring"><code class="name flex">
<span>def <span class="ident">fakedir_fromstring</span></span>(<span>s, start_chars=None, name_chars=None, header_regex=None, name_regex=None, supername='FakeDir', parse_comments=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a string folder tree diagram into a <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code>.
This can be used to read in external representations of folder structures,
edit them, and recreate them in a new location.</p>
<p>This function has mostly been tested with examples from Stack Overflow
and other Python learning sites (as well as output from <code><a title="seedir.realdir.seedir" href="realdir.html#seedir.realdir.seedir">seedir()</a></code>).
There are surely cases which will causes errors or unexpected results.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; s = &quot;&quot;&quot;doc/
... ├─_static/
... │ ├─embedded/
... │ │ ├─deep_file
... │ │ └─very/
... │ │   └─deep/
... │ │     └─folder/
... │ │       └─very_deep_file
... │ └─less_deep_file
... ├─about.rst
... ├─conf.py
... └─index.rst&quot;&quot;&quot;

&gt;&gt;&gt; f = sd.fakedir_fromstring(s) # now can be edited or restyled
&gt;&gt;&gt; f.seedir(style='spaces')
doc/
  _static/
    embedded/
      deep_file
      very/
        deep/
          folder/
            very_deep_file
    less_deep_file
  about.rst
  conf.py
  index.rst

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>String representation a folder tree.</dd>
<dt><strong><code>start_chars</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A string of characters which will be searched for as the start
of a folder or file name. The default is <code>None</code>, in which case the
characters are all letters, numbers, and punctuation marks except
for <code>/:?"*&lt;&gt;|</code> or <code>+=-</code>.</dd>
<dt><strong><code>name_chars</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A string of characters which will be searched for as being part
of a file or folder name. The default is <code>None</code>, in which case the
characters are all letters, numbers, punctuation marks except
for <code>/:?"*&lt;&gt;|,</code> and spaces.</dd>
<dt><strong><code>header_regex</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Regular expression to match the "header" of each line, i.e. the
structural characters of the folder diagram.
The default is <code>None</code>.
If passed, the <code>start_chars</code> argument will be ignored.
This and
<code>name_regex</code> are intended to provide functionality for parsing
specific or unusual cases.</dd>
<dt><strong><code>name_regex</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Regular expression to match all the folder or file names.
The default is <code>None</code>.
If passed, the <code>start_chars</code> argument will be ignored.</dd>
<dt><strong><code>supername</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name to give the head directory if one cannot be found.
The default is <code>'FakeDir'</code>.
This can happen when there is no clear
head directory in the string.</dd>
<dt><strong><code>parse_comments</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Try to parse and remove Python comments (following <code>#</code>).
The default is <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code></dt>
<dd>Fake directory corresponding to the input string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fakedir_fromstring(s, start_chars=None, name_chars=None,
                       header_regex=None, name_regex=None,
                       supername=&#39;FakeDir&#39;, parse_comments=True):
    &#39;&#39;&#39;
    Convert a string folder tree diagram into a `seedir.fakedir.FakeDir`.
    This can be used to read in external representations of folder structures,
    edit them, and recreate them in a new location.

    This function has mostly been tested with examples from Stack Overflow
    and other Python learning sites (as well as output from `seedir.realdir.seedir()`).
    There are surely cases which will causes errors or unexpected results.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; s = &#34;&#34;&#34;doc/
    ... ├─_static/
    ... │ ├─embedded/
    ... │ │ ├─deep_file
    ... │ │ └─very/
    ... │ │   └─deep/
    ... │ │     └─folder/
    ... │ │       └─very_deep_file
    ... │ └─less_deep_file
    ... ├─about.rst
    ... ├─conf.py
    ... └─index.rst&#34;&#34;&#34;

    &gt;&gt;&gt; f = sd.fakedir_fromstring(s) # now can be edited or restyled
    &gt;&gt;&gt; f.seedir(style=&#39;spaces&#39;)
    doc/
      _static/
        embedded/
          deep_file
          very/
            deep/
              folder/
                very_deep_file
        less_deep_file
      about.rst
      conf.py
      index.rst

    ```


    Parameters
    ----------
    s : str
        String representation a folder tree.
    start_chars : str, optional
        A string of characters which will be searched for as the start
        of a folder or file name. The default is `None`, in which case the
        characters are all letters, numbers, and punctuation marks except
        for `/:?&#34;*&lt;&gt;|` or `+=-`.
    name_chars : str, optional
        A string of characters which will be searched for as being part
        of a file or folder name. The default is `None`, in which case the
        characters are all letters, numbers, punctuation marks except
        for `/:?&#34;*&lt;&gt;|,` and spaces.
    header_regex : str, optional
        Regular expression to match the &#34;header&#34; of each line, i.e. the
        structural characters of the folder diagram.  The default is `None`.
        If passed, the `start_chars` argument will be ignored.  This and
        `name_regex` are intended to provide functionality for parsing
        specific or unusual cases.
    name_regex : str, optional
        Regular expression to match all the folder or file names.
        The default is `None`.
        If passed, the `start_chars` argument will be ignored.
    supername : str, optional
        Name to give the head directory if one cannot be found.
        The default is `&#39;FakeDir&#39;`.  This can happen when there is no clear
        head directory in the string.
    parse_comments : bool, optional
        Try to parse and remove Python comments (following `#`).
        The default is `True`.

    Returns
    -------
    seedir.fakedir.FakeDir
        Fake directory corresponding to the input string.

    &#39;&#39;&#39;
    slashes = [&#39;/&#39;, &#39;\\&#39;, os.sep]
    joinedslashes = &#39;&#39;.join(slashes)

    byline = s.split(&#39;\n&#39;)
    keyboard_chars = (string.ascii_letters + string.digits
                      + string.punctuation)
    filtered = &#34;&#34;.join([c for c in keyboard_chars if c not in &#39;/:?&#34;*&lt;&gt;|&#39;])
    if start_chars is None:
        start_chars = &#34;&#34;.join([c for c in filtered if c not in &#39;+=-&#39;])
    if name_chars is None:
        name_chars = filtered + &#39; &#39; + &#39;-&#39;

    names = []
    headers = []
    depths = []

    for line in byline:
        if not line:
            continue
        if header_regex is None:
            header = re.match(&#39;.*?(?=[{}])&#39;.format(start_chars), line)
        else:
            header = re.match(header_regex, line)
        if header is None:
            continue
        else:
            header = header.group()
        depth = len(header)
        if name_regex is None:
            name = re.match(&#39;[{}]*[/\\\\]*&#39;.format(name_chars), line[depth:])
        else:
            name = re.match(name_regex, line)
        if name is None:
            continue
        else:
            name = name.group()
        if &#39;#&#39; in name and parse_comments:
            name = re.match(&#39;.*?(?=#)&#39;, name).group().strip()
        if not name:
            continue

        headers.append(header)
        names.append(name)
        depths.append(depth)

    fakeitems = []
    superparent = None
    min_depth = min(depths)
    if len([d for d in depths if d == min_depth]) &gt; 1:
        superparent = FakeDir(supername)
    min_depth_index1 = depths.index(min_depth)
    if any(i &gt; min_depth for i in depths[:min_depth_index1]):
        superparent = FakeDir(supername)

    for i, name in enumerate(names):
        is_folder = False
        if name.strip()[-1] in slashes:
            is_folder = True
        if i &lt; len(names) - 1:
            if depths[i + 1] &gt; depths[i]:
                is_folder = True

        fmt_name = name.rstrip(joinedslashes)

        if depths[i] == min_depth:
            if is_folder:
                fakeitems.append(FakeDir(fmt_name, parent=superparent))
            else:
                fakeitems.append(FakeFile(fmt_name, parent=superparent))
        else:
            shallower = [d for d in depths[:i] if d &lt; depths[i]]
            if shallower:
                max_shallower = max([d for d in depths[:i] if d &lt; depths[i]])
                parent_index = max(idx for idx, val in enumerate(depths[:i])
                                   if val == max_shallower)
                parent = fakeitems[parent_index]
            else:
                parent = superparent
            if is_folder:
                fakeitems.append(FakeDir(fmt_name, parent=parent))
            else:
                fakeitems.append(FakeFile(fmt_name, parent=parent))

    if superparent is not None:
        return superparent
    else:
        idx = depths.index(min_depth)
        return fakeitems[idx]</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.populate"><code class="name flex">
<span>def <span class="ident">populate</span></span>(<span>fakedir, depth=3, folders=2, files=2, stopchance=0.5, seed=None, extensions=['txt'])</span>
</code></dt>
<dd>
<div class="desc"><p>Function for populating <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> objects with random files and folders.
Used by <code><a title="seedir.fakedir.randomdir" href="#seedir.fakedir.randomdir">randomdir()</a></code>.
Random dictionary names are chosen
for file and folder names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fakedir</code></strong> :&ensp;<code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code></dt>
<dd>Fake directory to populate.</dd>
<dt><strong><code>depth</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum depth to create folders and files. The default is <code>3</code>.</dd>
<dt><strong><code>folders</code></strong> :&ensp;<code>int</code> or <code>collection</code> of <code>integers</code>, optional</dt>
<dd>Parameter for setting the number of folders per directory.
The default is <code>2</code>.
If <code>int</code>, represents the number of folders
per directory.
If collection of integers, a random value will be
chosen from the collection each time a directory is popualted.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>int</code> or <code>collection</code> of <code>integers</code>, optional, optional</dt>
<dd>Same as the folders parameter, but for files.</dd>
<dt><strong><code>stopchance</code></strong> :&ensp;<code>float between 0 and 1</code>, optional</dt>
<dd>Chance that an added folder will not be populated. The default is <code>.5</code>.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Random seed. The default is <code>None</code>.</dd>
<dt><strong><code>extensions</code></strong> :&ensp;<code>list-likie</code>, optional</dt>
<dd>Collection of extensions to randomly select from for files.
The
default is <code>['txt']</code>.
Leading period can be included or omitted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Issue selecting int from folders or files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None, input is modified in place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate(fakedir, depth=3, folders=2, files=2, stopchance=.5, seed=None,
             extensions=[&#39;txt&#39;]):
    &#39;&#39;&#39;
    Function for populating `seedir.fakedir.FakeDir` objects with random files and folders.
    Used by `seedir.fakedir.randomdir()`.  Random dictionary names are chosen
    for file and folder names.

    Parameters
    ----------
    fakedir : seedir.fakedir.FakeDir
        Fake directory to populate.
    depth : int, optional
        Maximum depth to create folders and files. The default is `3`.
    folders : int or collection of integers, optional
        Parameter for setting the number of folders per directory.
        The default is `2`.  If `int`, represents the number of folders
        per directory.  If collection of integers, a random value will be
        chosen from the collection each time a directory is popualted.
    files : int or collection of integers, optional, optional
        Same as the folders parameter, but for files.
    stopchance : float between 0 and 1, optional
        Chance that an added folder will not be populated. The default is `.5`.
    seed : int or float, optional
        Random seed. The default is `None`.
    extensions : list-likie, optional
        Collection of extensions to randomly select from for files.  The
        default is `[&#39;txt&#39;]`.  Leading period can be included or omitted.

    Raises
    ------
    ValueError
        Issue selecting int from folders or files.

    Returns
    -------
    None, input is modified in place.

    &#39;&#39;&#39;
    random.seed(seed)
    if not isinstance(folders, int):
        try:
            fold_num = get_random_int(folders, seed=seed)
        except:
            raise ValueError(&#39;folders must be an int or collection of int&#39;)
    else:
        fold_num = folders
    if not isinstance(files, int):
        try:
            file_num = get_random_int(files, seed=seed)
        except:
            raise ValueError(&#39;files must be an int or collection of int&#39;)
    else:
        file_num = files
    for i in range(file_num):
        name = random.choice(words) + random.choice(extensions)
        while name in [f.name for f in fakedir._children]:
            name = random.choice(words) + random.choice(extensions)
        fakedir.create_file(name)
    for i in range(fold_num):
        name = random.choice(words)
        while name in [f.name for f in fakedir._children]:
            name = random.choice(words)
        fakedir.create_folder(name)
    for f in fakedir._children:
        if isinstance(f, FakeDir):
            if f.depth &lt;= depth and random.uniform(0, 1) &gt; stopchance:
                if seed is not None:
                    seed += random.random()
                populate(f, depth=depth, folders=folders, files=files,
                         seed=seed, stopchance=stopchance,
                         extensions=extensions)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.randomdir"><code class="name flex">
<span>def <span class="ident">randomdir</span></span>(<span>depth=2, files=range(1, 4), folders=range(0, 4), stopchance=0.5, seed=None, name='MyFakeDir', extensions=['txt'])</span>
</code></dt>
<dd>
<div class="desc"><p>Create a randomized <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code>, initialized with random
dictionary words.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; sd.randomdir(seed=7)
MyFakeDir/
├─Hardin.txt
├─Kathleen.txt
├─berserk/
└─pineapple/
  ├─visceral.txt
  ├─gestural.txt
  ├─plenty.txt
  ├─discoid/
  │ ├─eclat.txt
  │ └─milord/
  ├─Offenbach/
  │ ├─Trianon.txt
  │ ├─Monday.txt
  │ ├─ditty.txt
  │ ├─peddle/
  │ ├─delta/
  │ └─irredentism/
  └─Perseus/
    ├─hothouse.txt
    ├─clock.txt
    ├─covetous/
    └─Ekstrom/

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>depth</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum depth to create folders and files. The default is <code>3</code>.</dd>
<dt><strong><code>folders</code></strong> :&ensp;<code>int</code> or <code>collection</code> of <code>integers</code>, optional</dt>
<dd>Parameter for setting the number of folders per directory.
The default is <code>range(1,4)</code>.
If <code>int</code>, represents the number of folders
per directory.
If collection of integers, a random value will be
chosen from the collection each time a directory is popualted.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>int</code> or <code>collection</code> of <code>integers</code>, optional, optional</dt>
<dd>Same as the <code>folders</code> parameter, but for files.
The default
is <code>range(0,4)</code>.</dd>
<dt><strong><code>stopchance</code></strong> :&ensp;<code>float between 0 and 1</code>, optional</dt>
<dd>Chance that an added folder will not be populated. The default is <code>.5</code>.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Random seed. The default is <code>None</code>.</dd>
<dt><strong><code>extensions</code></strong> :&ensp;<code>list-likie</code>, optional</dt>
<dd>Collection of extensions to randomly select from for files.
The
default is <code>['txt']</code>.
Leading period can be included or omitted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>top</code></strong> :&ensp;<code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code></dt>
<dd>Fake directory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomdir(depth=2, files=range(1,4), folders=range(0,4),
              stopchance=.5, seed=None, name=&#39;MyFakeDir&#39;, extensions=[&#39;txt&#39;]):
    &#39;&#39;&#39;
    Create a randomized `seedir.fakedir.FakeDir`, initialized with random
    dictionary words.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; sd.randomdir(seed=7)
    MyFakeDir/
    ├─Hardin.txt
    ├─Kathleen.txt
    ├─berserk/
    └─pineapple/
      ├─visceral.txt
      ├─gestural.txt
      ├─plenty.txt
      ├─discoid/
      │ ├─eclat.txt
      │ └─milord/
      ├─Offenbach/
      │ ├─Trianon.txt
      │ ├─Monday.txt
      │ ├─ditty.txt
      │ ├─peddle/
      │ ├─delta/
      │ └─irredentism/
      └─Perseus/
        ├─hothouse.txt
        ├─clock.txt
        ├─covetous/
        └─Ekstrom/

    ```

    Parameters
    ----------
    depth : int, optional
        Maximum depth to create folders and files. The default is `3`.
    folders : int or collection of integers, optional
        Parameter for setting the number of folders per directory.
        The default is `range(1,4)`.  If `int`, represents the number of folders
        per directory.  If collection of integers, a random value will be
        chosen from the collection each time a directory is popualted.
    files : int or collection of integers, optional, optional
        Same as the `folders` parameter, but for files.  The default
        is `range(0,4)`.
    stopchance : float between 0 and 1, optional
        Chance that an added folder will not be populated. The default is `.5`.
    seed : int or float, optional
        Random seed. The default is `None`.
    extensions : list-likie, optional
        Collection of extensions to randomly select from for files.  The
        default is `[&#39;txt&#39;]`.  Leading period can be included or omitted.

    Returns
    -------
    top : seedir.fakedir.FakeDir
        Fake directory.

    &#39;&#39;&#39;
    top = FakeDir(name)
    new_ex = []
    for x in extensions:
        if x[0] != &#39;.&#39;:
            new_ex.append(&#39;.&#39; + x)
        else:
            new_ex.append(x)
    populate(top, depth, folders, files, seed=seed, stopchance=stopchance,
             extensions=new_ex)
    return top</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="seedir.fakedir.FakeDir"><code class="flex name class">
<span>class <span class="ident">FakeDir</span></span>
<span>(</span><span>name, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent fake folders.
Can be used to create
custom folder tree diagrams.
See <code><a title="seedir.fakedir.fakedir" href="#seedir.fakedir.fakedir">fakedir()</a></code> for converting
a real directory into a FakeDir, <code><a title="seedir.fakedir.fakedir_fromstring" href="#seedir.fakedir.fakedir_fromstring">fakedir_fromstring()</a></code> for
converting a text folder diagram into a <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code>, and <code><a title="seedir.fakedir.randomdir" href="#seedir.fakedir.randomdir">randomdir()</a></code>
for creating a random one.</p>
<p>To make a <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> from scratch, use this class:</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; x = sd.FakeDir('myfakedir')
&gt;&gt;&gt; x.seedir()
myfakedir/

</code></pre>
<p>There are various ways to add to it:</p>
<pre><code># using methods; the created items are returned
&gt;&gt;&gt; x.create_file(['__init__.py', 'main.py', 'styles.txt'])
[FakeFile(myfakedir/__init__.py), FakeFile(myfakedir/main.py), FakeFile(myfakedir/styles.txt)]
&gt;&gt;&gt; x.create_folder('docs')
docs/

# initializing new objects and setting the parent
&gt;&gt;&gt; y = sd.FakeDir('resources', parent=x)

# changing the parent of existing objects
&gt;&gt;&gt; z = sd.FakeDir('images')
&gt;&gt;&gt; z.parent = y

&gt;&gt;&gt; for n in ['a', 'b', 'c']:
...     z.create_file(n + '.png')
FakeFile(myfakedir/resources/images/a.png)
FakeFile(myfakedir/resources/images/b.png)
FakeFile(myfakedir/resources/images/c.png)

&gt;&gt;&gt; x.seedir(sort=True, first='folders')
myfakedir/
├─docs/
├─resources/
│ └─images/
│   ├─a.png
│   ├─b.png
│   └─c.png
├─__init__.py
├─main.py
└─styles.txt

</code></pre>
<p>You can index with path-like strings:</p>
<pre><code>&gt;&gt;&gt; x['resources/images/a.png']
FakeFile(myfakedir/resources/images/a.png)

</code></pre>
<p>Same as <code><a title="seedir.fakedir.FakeItem" href="#seedir.fakedir.FakeItem">FakeItem</a></code> initialization, but adds
the <code>_children</code> attribute for keeping track of items inside the fake dir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FakeDir(FakeItem):
    &#39;&#39;&#39;Class to represent fake folders.  Can be used to create
    custom folder tree diagrams.  See `seedir.fakedir.fakedir()` for converting
    a real directory into a FakeDir, `seedir.fakedir.fakedir_fromstring()` for
    converting a text folder diagram into a `FakeDir`, and `seedir.fakedir.randomdir()`
    for creating a random one.

    To make a `FakeDir` from scratch, use this class:

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; x = sd.FakeDir(&#39;myfakedir&#39;)
    &gt;&gt;&gt; x.seedir()
    myfakedir/

    ```

    There are various ways to add to it:

    ```
    # using methods; the created items are returned
    &gt;&gt;&gt; x.create_file([&#39;__init__.py&#39;, &#39;main.py&#39;, &#39;styles.txt&#39;])
    [FakeFile(myfakedir/__init__.py), FakeFile(myfakedir/main.py), FakeFile(myfakedir/styles.txt)]
    &gt;&gt;&gt; x.create_folder(&#39;docs&#39;)
    docs/

    # initializing new objects and setting the parent
    &gt;&gt;&gt; y = sd.FakeDir(&#39;resources&#39;, parent=x)

    # changing the parent of existing objects
    &gt;&gt;&gt; z = sd.FakeDir(&#39;images&#39;)
    &gt;&gt;&gt; z.parent = y

    &gt;&gt;&gt; for n in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]:
    ...     z.create_file(n + &#39;.png&#39;)
    FakeFile(myfakedir/resources/images/a.png)
    FakeFile(myfakedir/resources/images/b.png)
    FakeFile(myfakedir/resources/images/c.png)

    &gt;&gt;&gt; x.seedir(sort=True, first=&#39;folders&#39;)
    myfakedir/
    ├─docs/
    ├─resources/
    │ └─images/
    │   ├─a.png
    │   ├─b.png
    │   └─c.png
    ├─__init__.py
    ├─main.py
    └─styles.txt

    ```

    You can index with path-like strings:

    ```
    &gt;&gt;&gt; x[&#39;resources/images/a.png&#39;]
    FakeFile(myfakedir/resources/images/a.png)

    ```

    &#39;&#39;&#39;
    def __init__(self, name, parent=None):
        &#39;&#39;&#39;Same as `seedir.fakedir.FakeItem` initialization, but adds
        the `_children` attribute for keeping track of items inside the fake dir.
        &#39;&#39;&#39;
        # alter children through FakeDir methods!
        self._children = []
        super().__init__(name, parent)

    def __str__(self):
        &#39;&#39;&#39;String conversion of `FakeDir`&#39;&#39;&#39;
        return &#39;FakeDir({})&#39;.format(self.get_path())

    def __repr__(self):
        &#39;&#39;&#39;Representation of `FakeDir` (shown as a folder diagram).&#39;&#39;&#39;
        return self.seedir(printout=False)

    def __getitem__(self, path):
        &#34;&#34;&#34;Use path-like strings to index `FakeDir` objects.&#34;&#34;&#34;
        if not isinstance(path, str):
            raise TypeError(&#34;Can only index FakeDir with int or str, &#34;
                            &#34;not {}&#34;.format(type(path)))
        paths = path.split(&#39;/&#39;)
        current = self
        for p in paths:
            for f in current._children:
                if p == f.name:
                    current = f
                    break
            else:
                raise(FakedirError(&#39;Path &#34;{}&#34; not found through {}&#39;.format(path, self)))
        return current

    def create_folder(self, name):
        &#34;&#34;&#34;
        Create a new folder (`seedir.fakedir.FakeDir`) as a child.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; x = sd.FakeDir(&#39;Test&#39;)
        &gt;&gt;&gt; x.create_folder(&#34;new_folder&#34;)
        new_folder/
        &gt;&gt;&gt; x.seedir()
        Test/
        └─new_folder/

        ```

        Parameters
        ----------
        name : str
            Name of the new folder.  Can also be a collection of names to create
            multiple folders.

        Returns
        -------
        FakeDir or list
            The new object or objects (as a list) are returned.

        &#34;&#34;&#34;
        if isinstance(name, str):
            return FakeDir(name, parent=self)
        else:
            return [FakeDir(s, parent=self) for s in name]

    def create_file(self, name):
        &#34;&#34;&#34;
        Create a new file (`seedir.fakedir.FakeFile`) as a child.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; x = sd.FakeDir(&#39;Test&#39;)
        &gt;&gt;&gt; x.create_file(&#34;new_file.txt&#34;)
        FakeFile(Test/new_file.txt)
        &gt;&gt;&gt; x.seedir()
        Test/
        └─new_file.txt

        ```

        Parameters
        ----------
        name : str
            Name of the new file.  Can also be a collection of names to create
            multiple files.

        Returns
        -------
        FakeFile or list
            The new object or objects (as a list) are returned.

        &#34;&#34;&#34;
        if isinstance(name, str):
            return FakeFile(name, parent=self)
        else:
            return [FakeFile(s, parent=self) for s in name]

    def copy(self):
        &#39;&#39;&#39;
        Generate a totally unlinked copy object.  The root of the new FakeDir
        will be a copy of this folder (and all its subfolders).  Calling this
        method does not alter self at all.

        Returns
        -------
        seedir.fakedir.FakeDir
            A copy FakeDir.

        &#39;&#39;&#39;
        def recurse_build(f, other):
            &#39;&#39;&#39;Recursive helper for building the new copy.&#39;&#39;&#39;
            if f.isfile():
                new = FakeFile(name=f.name, parent=other)
            elif f.isdir():
                new = FakeDir(name=f.name, parent=other)
                for child in f.listdir():
                    recurse_build(child, other=new)
            return new

        return recurse_build(self, other=None)


    def delete(self, child):
        &#39;&#39;&#39;
        Delete items from a `seedir.fakedir.FakeDir`.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=5)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; r[&#39;zag&#39;].delete([&#39;thematic.txt&#39;, &#39;inelastic.txt&#39;]) # delete with string names
        &gt;&gt;&gt; r.delete(r[&#39;monastic&#39;]) # delete with objects
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        └─zag/
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        ```

        Parameters
        ----------
        child : str, FakeDir, FakeFile or list-like
            Child or children to remove.  Can be a string name, actual
            `seedir.fakedir.FakeDir` / `seedir.fakedir.FakeFile` object,
            or a collection of names or items.

        Raises
        ------
        FakedirError
            No item found to delete.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        target = None
        if type(child) in [FakeDir, FakeFile]:
            target = child.name
        elif isinstance(child, str):
            target = child
        if target is not None:
            try:
                to_del = next(f for f in self._children if f.name == target)
                to_del.parent = None
            except StopIteration:
                raise FakedirError(&#39;{} has no child with name &#34;{}&#34;&#39;.format(self, target))
        else:
            child_copy = [c for c in child]
            for c in child_copy:
                target = None
                if type(c) in [FakeDir, FakeFile]:
                    target = c.name
                elif isinstance(c, str):
                    target = c
                if target is not None:
                    try:
                        to_del = next(f for f in self._children if
                                      f.name == target)
                        to_del.parent = None
                    except StopIteration:
                        raise FakedirError(&#39;{} has no child with name &#34;{}&#34;&#39;.format(self, target))

    def get_child_names(self):
        &#39;&#39;&#39;Return a list of child names.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=5)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; r.get_child_names()
        [&#39;senor.txt&#39;, &#39;verb.txt&#39;, &#39;takeoff.txt&#39;, &#39;monastic&#39;, &#39;zag&#39;]

        ```

        &#39;&#39;&#39;
        return [c.name for c in self._children]

    def listdir(self):
        &#39;&#39;&#39;Return the list of `seedir.fakedir.FakeFile` and `seedir.fakedir.FakeDir`
        objects that are children of `self` (like `os.listdir`).

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=1)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─churchmen.txt
        └─exposure/

        &gt;&gt;&gt; print([str(i) for i in r.listdir()])
        [&#39;FakeFile(MyFakeDir/churchmen.txt)&#39;, &#39;FakeDir(MyFakeDir/exposure)&#39;]

        ```
        &#39;&#39;&#39;
        return self._children

    def realize(self, path=None):
        &#39;&#39;&#39;
        Convert a fake file tree into a real one by creating a folder at a
        given path, and populating it with files and sub-directories.

        All files will be empty.

        ```
        import os

        import seedir as sd

        r = sd.randomdir(seed=1)
        # MyFakeDir/
        # ├─churchmen.txt
        # └─exposure/

        r.realize()
        os.path.isdir(&#39;MyFakeDir/exposure&#39;)
        # True
        ```

        Parameters
        ----------
        path : str, optional
            System path where to create the folder. The default is `None`,
            in which the current working directory is used.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        def create(f, root):
            fpath = f.get_path()
            joined = os.path.join(root, fpath)
            if isinstance(f, FakeDir):
                os.mkdir(joined)
            elif isinstance(f, FakeFile):
                with open(joined, &#39;w&#39;): pass;
        if path is None:
            path = os.getcwd()
        self.walk_apply(create, root=path)

    def seedir(self, style=&#39;lines&#39;, printout=True, indent=2, uniform=None,
               anystart=None, anyend=None, depthlimit=None, itemlimit=None,
               beyond=None, first=None, sort=False, sort_reverse=False, sort_key=None,
               include_folders=None, exclude_folders=None, include_files=None,
               exclude_files=None, regex=False, slash=&#39;/&#39;, mask=None,
               formatter=None, sticky_formatter=False, **kwargs):
        &#39;&#39;&#39;

        Create a folder tree diagram for `self`.  `seedir.fakedir.FakeDir` version of
        `seedir.realdir.seedir()` (see its documentation for examples).

        Parameters
        ----------
        style : &#39;lines&#39;, &#39;dash&#39;, &#39;arrow&#39;, &#39;spaces&#39;, &#39;plus&#39;, or &#39;emoji&#39;, optional
            Style to use. The default is `&#39;lines&#39;`.  A style determines the set
            of characters (&#34;tokens&#34;) used to represent the base structure of
            the directory (e.g. which items belong to which folders, when items
            are the last member of a folder, etc.).  The actual tokens being used
            by each style can be viewed with `seedir.printing.get_styleargs()`.
        printout : bool, optional
            Print the folder structure in the console. The default is `True`.  When
            `False`, the folder diagram is returned as a string.
        indent : int (&gt;= 0), optional
            Number of spaces separating items from their parent folder.
            The default is `2`.
        uniform : str or None, optional
            Characters to use for all tokens when creating the tree diagram.
            The default is `None`.  When not `None`, the extend, space, split, and
            final tokens are replaced with `uniform` (the `&#39;spaces&#39;` style is
            essentially `uniform = &#39;  &#39;`).
        anystart : str or None, optional
            Characters to append before any item (i.e. folder or file).  The
            default is `None`.  Specific starts for folders and files can be
            specified (see `**kwargs`).
        anyend : str or None, optional
            Characters to append after any item (i.e. folder or file).  The
            default is `None`.  Specific ends for folders and files can be
            specified (see `**kwargs`).
        depthlimit : int or None, optional
            Limit the depth of folders to traverse.  Folders at the `depthlimit` are
            included, but their contents are not shown (with the exception of the
            beyond parameter being specified).  The default is `None`, which can
            cause exceptionally long runtimes for deep or extensive directories.
        itemlimit : int or None, optional
            Limit the number of items in a directory to show.  Items beyond the
            `itemlimit` can be expressed using the `beyond` parameter.  The files and
            folders left out are determined by the sorting parameters
            (`sort`, `sort_reverse`, `sort_key`).  The default is `None`.
        beyond : str (&#39;ellipsis&#39;, &#39;content&#39; or a string starting with an underscore) or None, optional
            String to indicate directory contents beyond the `itemlimit` or the
            `depthlimit`.  The default is `None`.  Options are: `&#39;ellipsis&#39;` (`&#39;...&#39;`),
            `&#39;content&#39;` or `&#39;contents&#39;` (the number of files and folders beyond), or
            a string starting with `&#39;_&#39;` (everything after the leading underscore
            will be returned)
        first : &#39;files&#39;, &#39;folders&#39;, or None, optional
            Sort the directory so that either files or folders appear first.
            The default is `None`.
        sort : bool, optional
            Sort the directory. With no other specifications, the sort will be a
            simple alphabetical sort of the item names, but this can be altered
            with the `first`, `sort_reverse`, and `sort_key parameters`.
            The default is `False`.
        sort_reverse : bool, optional
            Reverse the sorting determined by `sort` or `sort_key`.
            The default is `False`.
        sort_key : function, optional
            Key to use for sorting file or folder names, akin to the `key` parameter
            of the builtin `sorted()` or `list.sort()`. The function should take a
            string as an argument. The default is `None`.
        include_folders, exclude_folders, include_files, exclude_files : str, list-like, or None, optional
            Folder / file names to include or exclude. The default is `None`.  By
            default, these are interpreted literally.  Pass `regex=True` for
            using regular expressions.
        regex : bool, optional
            Interpret the strings of include/exclude file/folder arguments as
            regular expressions. The default is `False`.
        mask : function, optional
            Function for filtering items.  Each individual item object
            is passed to the mask function.  If `True` is returned, the
            item is kept.  The default is `None`.
        formatter : function, optional
            Function for customizing the directory printing logic and style
            based on specific folders &amp; files.  When passed, the formatter
            is called on each item in the file tree, and the current arguments
            are updated based what is returned.

            The formatter function should accept a FakeItem as a
            single argument (either relative or absolute, depending on what is passed
            to the `path` argument), and it should return either a dictionary or None.
            The dictionary should have names of arguments as keys and their respective
            setting as values.

            The following options can meaningfully be toggled by passing a formatter
            function: `depthlimit`, `itemlimit`, `beyond`, `first`, `sort`, `sort_reverse`,
            `sort_key`, `include_folders`, `regex`, `mask`, as well as any seedir token
            keywords (`extend`, `space`, `split`, `final`, `folderstart`, `filestart`,
            `folderend`, `fileend`).

            Note that in version 0.3.0, formatter could only be used to update
            the style tokens.  It can now be used to udpate those as well as the other
            arguments listed above.

            If None is returned by formatter, the tokens will be set by `style`.

            Note that items exlcuded by the inclusion/exclusion arguments (or the
            `mask`) *will not* be seen by formatter.  Similarly, any folder tree
            entries created by the `beyond` argument *will not* be seen by formatter.

        sticky_formatter : bool, optional
            When True, updates to argumnts made by the `formatter` (see above)
            will be permanent.  Thus, if arguments are updated when the `formatter`
            is called on a folder, its children will (recursively) inherit
            those new arguments.
        slash : str, option:
            **`DeprecationWarning`**: *With addition of `folderend` in v0.3.1,
            `slash` is to be deprecated in a future version.*

            Slash character to follow folders.  If `&#39;sep&#39;`, uses `os.sep`.  The
            default is `&#39;/&#39;`.
        **kwargs : str
            Specific tokens to use for creating the file tree diagram.  The tokens
            use by each builtin style can be seen with `seedir.printing.get_styleargs()`.
            Valid options are `extend` (characters to show the extension of a directory
            while its children are traversed), `space` (character to provide the
            correct indentation of an item when some of its parent / grandparent
            directories are completely traversed), `split` (characters to show a
            folder or file within a directory, with more items following),
            `final` (characters to show a folder or file within a directory,
            with no more items following), `folderstart` (characters to prepend
            before any folder), `filestart` (characters to preppend before any
            file), `folderend` (characters to append after any folder), and
            `fileend` (characters to append after any file). The following shows
            the default tokens for the `&#39;lines&#39;` style:

                &gt;&gt;&gt; import seedir as sd
                &gt;&gt;&gt; sd.get_styleargs(&#39;lines&#39;)
                {&#39;split&#39;: &#39;├─&#39;, &#39;extend&#39;: &#39;│ &#39;, &#39;space&#39;: &#39;  &#39;, &#39;final&#39;: &#39;└─&#39;, &#39;folderstart&#39;: &#39;&#39;, &#39;filestart&#39;: &#39;&#39;, &#39;folderend&#39;: &#39;/&#39;, &#39;fileend&#39;: &#39;&#39;}

            All default style tokens are 2 character strings, except for
            the file/folder start/end tokens.  Style tokens from `**kwargs` are not
            affected by the indent parameter.  The `uniform`, `anystart`, and
            `anyend` parameters can be used to affect multiple style tokens.

        Returns
        -------
        s (str) or None
            The tree diagram (as a string) or None if prinout = True, in which
            case the tree diagram is printed in the console.

        &#39;&#39;&#39;

        # call
        args = dict(style=style,
                    printout=printout,
                    indent=indent,
                    uniform=uniform,
                    anystart=anystart,
                    anyend=anyend,
                    depthlimit=depthlimit,
                    itemlimit=itemlimit,
                    beyond=beyond,
                    first=first,
                    sort=sort,
                    sort_reverse=sort_reverse,
                    sort_key=sort_key,
                    include_folders=include_folders,
                    exclude_folders=exclude_folders,
                    include_files=include_files,
                    exclude_files=exclude_files,
                    regex=regex,
                    mask=mask,
                    formatter=formatter,
                    sticky_formatter=sticky_formatter,
                    **kwargs)

        return FakeDirStructure(self, **args)

    def set_child_depths(self):
        &#39;&#39;&#39;Recursively set depths of `self` and its children.
        Called automatically when a new `parent` is assigned.&#39;&#39;&#39;
        def apply_setdepth(FD):
            FD.set_depth()
        self.walk_apply(apply_setdepth)

    def trim(self, depthlimit):
        &#34;&#34;&#34;
        Remove items beyond the `depthlimit`.

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=456)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─Vogel.txt
        ├─monkish.txt
        ├─jowly.txt
        ├─scrooge/
        │ ├─light.txt
        │ ├─reliquary.txt
        │ ├─sandal/
        │ ├─paycheck/
        │ │ ├─electrophoresis.txt
        │ │ └─Pyongyang/
        │ └─patrimonial/
        ├─Uganda/
        └─pedantic/
          └─cataclysmic.txt

        &gt;&gt;&gt; r.trim(1)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─Vogel.txt
        ├─monkish.txt
        ├─jowly.txt
        ├─scrooge/
        ├─Uganda/
        └─pedantic/

        ```


        Parameters
        ----------
        depthlimit : non-negative int
            Files beyond this depth will be cut. The root has depth `0`.

        Raises
        ------
        ValueError
            `depthlimit` is not a non-negative int

        Returns
        -------
        None.

        &#34;&#34;&#34;
        depthlimit = int(depthlimit)
        if depthlimit &lt; 0:
            raise ValueError(&#39;depthlimit must be non-negative int&#39;)
        depthlimit += self.depth
        def trim_apply(f, depthlimit):
            if depthlimit is not None and f.depth == depthlimit:
                if isinstance(f, FakeDir):
                    f.delete(f.listdir())
        if depthlimit == self.depth:
            self.delete(self.listdir())
        else:
            self.walk_apply(trim_apply, depthlimit=depthlimit)

    def walk_apply(self, foo, *args, **kwargs):
        &#34;&#34;&#34;
        Recursively apply a function the children of self (and so on)

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; r = sd.randomdir(seed=5)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; def replace_txt(f):
        ...    f.name = f.name.replace(&#39;txt&#39;, &#39;pdf&#39;)

        &gt;&gt;&gt; r.walk_apply(replace_txt)
        &gt;&gt;&gt; r
        MyFakeDir/
        ├─senor.pdf
        ├─verb.pdf
        ├─takeoff.pdf
        ├─monastic/
        │ ├─paddy.pdf
        │ ├─ewe.pdf
        │ ├─advantage.pdf
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.pdf
          ├─inelastic.pdf
          ├─fierce.pdf
          ├─gout/
          └─stein/
            ├─vector.pdf
            ├─sora.pdf
            └─proviso.pdf

        ```

        Parameters
        ----------
        foo : function
            Function to apply.
        *args :
            Additional positional arguments for `foo`.
        **kwargs :
            Additional keyword arguments for `foo`.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        foo(self, *args, **kwargs)
        for f in self._children:
            if isinstance(f, FakeDir):
                f.walk_apply(foo, *args, **kwargs)
            else:
                foo(f, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="seedir.fakedir.FakeItem" href="#seedir.fakedir.FakeItem">FakeItem</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="seedir.fakedir.FakeDir.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a totally unlinked copy object.
The root of the new FakeDir
will be a copy of this folder (and all its subfolders).
Calling this
method does not alter self at all.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code></dt>
<dd>A copy FakeDir.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#39;&#39;&#39;
    Generate a totally unlinked copy object.  The root of the new FakeDir
    will be a copy of this folder (and all its subfolders).  Calling this
    method does not alter self at all.

    Returns
    -------
    seedir.fakedir.FakeDir
        A copy FakeDir.

    &#39;&#39;&#39;
    def recurse_build(f, other):
        &#39;&#39;&#39;Recursive helper for building the new copy.&#39;&#39;&#39;
        if f.isfile():
            new = FakeFile(name=f.name, parent=other)
        elif f.isdir():
            new = FakeDir(name=f.name, parent=other)
            for child in f.listdir():
                recurse_build(child, other=new)
        return new

    return recurse_build(self, other=None)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.create_file"><code class="name flex">
<span>def <span class="ident">create_file</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new file (<code><a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></code>) as a child.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; x = sd.FakeDir('Test')
&gt;&gt;&gt; x.create_file(&quot;new_file.txt&quot;)
FakeFile(Test/new_file.txt)
&gt;&gt;&gt; x.seedir()
Test/
└─new_file.txt

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the new file.
Can also be a collection of names to create
multiple files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></code> or <code>list</code></dt>
<dd>The new object or objects (as a list) are returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_file(self, name):
    &#34;&#34;&#34;
    Create a new file (`seedir.fakedir.FakeFile`) as a child.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; x = sd.FakeDir(&#39;Test&#39;)
    &gt;&gt;&gt; x.create_file(&#34;new_file.txt&#34;)
    FakeFile(Test/new_file.txt)
    &gt;&gt;&gt; x.seedir()
    Test/
    └─new_file.txt

    ```

    Parameters
    ----------
    name : str
        Name of the new file.  Can also be a collection of names to create
        multiple files.

    Returns
    -------
    FakeFile or list
        The new object or objects (as a list) are returned.

    &#34;&#34;&#34;
    if isinstance(name, str):
        return FakeFile(name, parent=self)
    else:
        return [FakeFile(s, parent=self) for s in name]</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.create_folder"><code class="name flex">
<span>def <span class="ident">create_folder</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new folder (<code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code>) as a child.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; x = sd.FakeDir('Test')
&gt;&gt;&gt; x.create_folder(&quot;new_folder&quot;)
new_folder/
&gt;&gt;&gt; x.seedir()
Test/
└─new_folder/

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the new folder.
Can also be a collection of names to create
multiple folders.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> or <code>list</code></dt>
<dd>The new object or objects (as a list) are returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_folder(self, name):
    &#34;&#34;&#34;
    Create a new folder (`seedir.fakedir.FakeDir`) as a child.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; x = sd.FakeDir(&#39;Test&#39;)
    &gt;&gt;&gt; x.create_folder(&#34;new_folder&#34;)
    new_folder/
    &gt;&gt;&gt; x.seedir()
    Test/
    └─new_folder/

    ```

    Parameters
    ----------
    name : str
        Name of the new folder.  Can also be a collection of names to create
        multiple folders.

    Returns
    -------
    FakeDir or list
        The new object or objects (as a list) are returned.

    &#34;&#34;&#34;
    if isinstance(name, str):
        return FakeDir(name, parent=self)
    else:
        return [FakeDir(s, parent=self) for s in name]</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, child)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete items from a <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code>.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; r = sd.randomdir(seed=5)
&gt;&gt;&gt; r
MyFakeDir/
├─senor.txt
├─verb.txt
├─takeoff.txt
├─monastic/
│ ├─paddy.txt
│ ├─ewe.txt
│ ├─advantage.txt
│ ├─hooves/
│ └─registrar/
└─zag/
  ├─thematic.txt
  ├─inelastic.txt
  ├─fierce.txt
  ├─gout/
  └─stein/
    ├─vector.txt
    ├─sora.txt
    └─proviso.txt

&gt;&gt;&gt; r['zag'].delete(['thematic.txt', 'inelastic.txt']) # delete with string names
&gt;&gt;&gt; r.delete(r['monastic']) # delete with objects
&gt;&gt;&gt; r
MyFakeDir/
├─senor.txt
├─verb.txt
├─takeoff.txt
└─zag/
  ├─fierce.txt
  ├─gout/
  └─stein/
    ├─vector.txt
    ├─sora.txt
    └─proviso.txt

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>child</code></strong> :&ensp;<code>str, <a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a>, <a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></code> or <code>list-like</code></dt>
<dd>Child or children to remove.
Can be a string name, actual
<code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> / <code><a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></code> object,
or a collection of names or items.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FakedirError</code></dt>
<dd>No item found to delete.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, child):
    &#39;&#39;&#39;
    Delete items from a `seedir.fakedir.FakeDir`.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; r = sd.randomdir(seed=5)
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─senor.txt
    ├─verb.txt
    ├─takeoff.txt
    ├─monastic/
    │ ├─paddy.txt
    │ ├─ewe.txt
    │ ├─advantage.txt
    │ ├─hooves/
    │ └─registrar/
    └─zag/
      ├─thematic.txt
      ├─inelastic.txt
      ├─fierce.txt
      ├─gout/
      └─stein/
        ├─vector.txt
        ├─sora.txt
        └─proviso.txt

    &gt;&gt;&gt; r[&#39;zag&#39;].delete([&#39;thematic.txt&#39;, &#39;inelastic.txt&#39;]) # delete with string names
    &gt;&gt;&gt; r.delete(r[&#39;monastic&#39;]) # delete with objects
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─senor.txt
    ├─verb.txt
    ├─takeoff.txt
    └─zag/
      ├─fierce.txt
      ├─gout/
      └─stein/
        ├─vector.txt
        ├─sora.txt
        └─proviso.txt

    ```

    Parameters
    ----------
    child : str, FakeDir, FakeFile or list-like
        Child or children to remove.  Can be a string name, actual
        `seedir.fakedir.FakeDir` / `seedir.fakedir.FakeFile` object,
        or a collection of names or items.

    Raises
    ------
    FakedirError
        No item found to delete.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    target = None
    if type(child) in [FakeDir, FakeFile]:
        target = child.name
    elif isinstance(child, str):
        target = child
    if target is not None:
        try:
            to_del = next(f for f in self._children if f.name == target)
            to_del.parent = None
        except StopIteration:
            raise FakedirError(&#39;{} has no child with name &#34;{}&#34;&#39;.format(self, target))
    else:
        child_copy = [c for c in child]
        for c in child_copy:
            target = None
            if type(c) in [FakeDir, FakeFile]:
                target = c.name
            elif isinstance(c, str):
                target = c
            if target is not None:
                try:
                    to_del = next(f for f in self._children if
                                  f.name == target)
                    to_del.parent = None
                except StopIteration:
                    raise FakedirError(&#39;{} has no child with name &#34;{}&#34;&#39;.format(self, target))</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.get_child_names"><code class="name flex">
<span>def <span class="ident">get_child_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of child names.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; r = sd.randomdir(seed=5)
&gt;&gt;&gt; r
MyFakeDir/
├─senor.txt
├─verb.txt
├─takeoff.txt
├─monastic/
│ ├─paddy.txt
│ ├─ewe.txt
│ ├─advantage.txt
│ ├─hooves/
│ └─registrar/
└─zag/
  ├─thematic.txt
  ├─inelastic.txt
  ├─fierce.txt
  ├─gout/
  └─stein/
    ├─vector.txt
    ├─sora.txt
    └─proviso.txt

&gt;&gt;&gt; r.get_child_names()
['senor.txt', 'verb.txt', 'takeoff.txt', 'monastic', 'zag']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_child_names(self):
    &#39;&#39;&#39;Return a list of child names.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; r = sd.randomdir(seed=5)
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─senor.txt
    ├─verb.txt
    ├─takeoff.txt
    ├─monastic/
    │ ├─paddy.txt
    │ ├─ewe.txt
    │ ├─advantage.txt
    │ ├─hooves/
    │ └─registrar/
    └─zag/
      ├─thematic.txt
      ├─inelastic.txt
      ├─fierce.txt
      ├─gout/
      └─stein/
        ├─vector.txt
        ├─sora.txt
        └─proviso.txt

    &gt;&gt;&gt; r.get_child_names()
    [&#39;senor.txt&#39;, &#39;verb.txt&#39;, &#39;takeoff.txt&#39;, &#39;monastic&#39;, &#39;zag&#39;]

    ```

    &#39;&#39;&#39;
    return [c.name for c in self._children]</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.listdir"><code class="name flex">
<span>def <span class="ident">listdir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list of <code><a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></code> and <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code>
objects that are children of <code>self</code> (like <code>os.listdir</code>).</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; r = sd.randomdir(seed=1)
&gt;&gt;&gt; r
MyFakeDir/
├─churchmen.txt
└─exposure/

&gt;&gt;&gt; print([str(i) for i in r.listdir()])
['FakeFile(MyFakeDir/churchmen.txt)', 'FakeDir(MyFakeDir/exposure)']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listdir(self):
    &#39;&#39;&#39;Return the list of `seedir.fakedir.FakeFile` and `seedir.fakedir.FakeDir`
    objects that are children of `self` (like `os.listdir`).

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; r = sd.randomdir(seed=1)
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─churchmen.txt
    └─exposure/

    &gt;&gt;&gt; print([str(i) for i in r.listdir()])
    [&#39;FakeFile(MyFakeDir/churchmen.txt)&#39;, &#39;FakeDir(MyFakeDir/exposure)&#39;]

    ```
    &#39;&#39;&#39;
    return self._children</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.realize"><code class="name flex">
<span>def <span class="ident">realize</span></span>(<span>self, path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a fake file tree into a real one by creating a folder at a
given path, and populating it with files and sub-directories.</p>
<p>All files will be empty.</p>
<pre><code>import os

import seedir as sd

r = sd.randomdir(seed=1)
# MyFakeDir/
# ├─churchmen.txt
# └─exposure/

r.realize()
os.path.isdir('MyFakeDir/exposure')
# True
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>System path where to create the folder. The default is <code>None</code>,
in which the current working directory is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def realize(self, path=None):
    &#39;&#39;&#39;
    Convert a fake file tree into a real one by creating a folder at a
    given path, and populating it with files and sub-directories.

    All files will be empty.

    ```
    import os

    import seedir as sd

    r = sd.randomdir(seed=1)
    # MyFakeDir/
    # ├─churchmen.txt
    # └─exposure/

    r.realize()
    os.path.isdir(&#39;MyFakeDir/exposure&#39;)
    # True
    ```

    Parameters
    ----------
    path : str, optional
        System path where to create the folder. The default is `None`,
        in which the current working directory is used.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    def create(f, root):
        fpath = f.get_path()
        joined = os.path.join(root, fpath)
        if isinstance(f, FakeDir):
            os.mkdir(joined)
        elif isinstance(f, FakeFile):
            with open(joined, &#39;w&#39;): pass;
    if path is None:
        path = os.getcwd()
    self.walk_apply(create, root=path)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.seedir"><code class="name flex">
<span>def <span class="ident">seedir</span></span>(<span>self, style='lines', printout=True, indent=2, uniform=None, anystart=None, anyend=None, depthlimit=None, itemlimit=None, beyond=None, first=None, sort=False, sort_reverse=False, sort_key=None, include_folders=None, exclude_folders=None, include_files=None, exclude_files=None, regex=False, slash='/', mask=None, formatter=None, sticky_formatter=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a folder tree diagram for <code>self</code>.
<code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> version of
<code><a title="seedir.realdir.seedir" href="realdir.html#seedir.realdir.seedir">seedir()</a></code> (see its documentation for examples).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>style</code></strong> :&ensp;<code>'lines', 'dash', 'arrow', 'spaces', 'plus',</code> or <code>'emoji'</code>, optional</dt>
<dd>Style to use. The default is <code>'lines'</code>.
A style determines the set
of characters ("tokens") used to represent the base structure of
the directory (e.g. which items belong to which folders, when items
are the last member of a folder, etc.).
The actual tokens being used
by each style can be viewed with <code><a title="seedir.printing.get_styleargs" href="printing.html#seedir.printing.get_styleargs">get_styleargs()</a></code>.</dd>
<dt><strong><code>printout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Print the folder structure in the console. The default is <code>True</code>.
When
<code>False</code>, the folder diagram is returned as a string.</dd>
<dt><strong><code>indent</code></strong> :&ensp;<code>int (&gt;= 0)</code>, optional</dt>
<dd>Number of spaces separating items from their parent folder.
The default is <code>2</code>.</dd>
<dt><strong><code>uniform</code></strong> :&ensp;<code>str</code> or <code>None</code>, optional</dt>
<dd>Characters to use for all tokens when creating the tree diagram.
The default is <code>None</code>.
When not <code>None</code>, the extend, space, split, and
final tokens are replaced with <code>uniform</code> (the <code>'spaces'</code> style is
essentially <code>uniform = '
'</code>).</dd>
<dt><strong><code>anystart</code></strong> :&ensp;<code>str</code> or <code>None</code>, optional</dt>
<dd>Characters to append before any item (i.e. folder or file).
The
default is <code>None</code>.
Specific starts for folders and files can be
specified (see <code>**kwargs</code>).</dd>
<dt><strong><code>anyend</code></strong> :&ensp;<code>str</code> or <code>None</code>, optional</dt>
<dd>Characters to append after any item (i.e. folder or file).
The
default is <code>None</code>.
Specific ends for folders and files can be
specified (see <code>**kwargs</code>).</dd>
<dt><strong><code>depthlimit</code></strong> :&ensp;<code>int</code> or <code>None</code>, optional</dt>
<dd>Limit the depth of folders to traverse.
Folders at the <code>depthlimit</code> are
included, but their contents are not shown (with the exception of the
beyond parameter being specified).
The default is <code>None</code>, which can
cause exceptionally long runtimes for deep or extensive directories.</dd>
<dt><strong><code>itemlimit</code></strong> :&ensp;<code>int</code> or <code>None</code>, optional</dt>
<dd>Limit the number of items in a directory to show.
Items beyond the
<code>itemlimit</code> can be expressed using the <code>beyond</code> parameter.
The files and
folders left out are determined by the sorting parameters
(<code>sort</code>, <code>sort_reverse</code>, <code>sort_key</code>).
The default is <code>None</code>.</dd>
<dt><strong><code>beyond</code></strong> :&ensp;<code>str ('ellipsis', 'content'</code> or <code>a string starting with an underscore)</code> or <code>None</code>, optional</dt>
<dd>String to indicate directory contents beyond the <code>itemlimit</code> or the
<code>depthlimit</code>.
The default is <code>None</code>.
Options are: <code>'ellipsis'</code> (<code>'...'</code>),
<code>'content'</code> or <code>'contents'</code> (the number of files and folders beyond), or
a string starting with <code>'_'</code> (everything after the leading underscore
will be returned)</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>'files', 'folders',</code> or <code>None</code>, optional</dt>
<dd>Sort the directory so that either files or folders appear first.
The default is <code>None</code>.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Sort the directory. With no other specifications, the sort will be a
simple alphabetical sort of the item names, but this can be altered
with the <code>first</code>, <code>sort_reverse</code>, and <code>sort_key parameters</code>.
The default is <code>False</code>.</dd>
<dt><strong><code>sort_reverse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Reverse the sorting determined by <code>sort</code> or <code>sort_key</code>.
The default is <code>False</code>.</dd>
<dt><strong><code>sort_key</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Key to use for sorting file or folder names, akin to the <code>key</code> parameter
of the builtin <code>sorted()</code> or <code>list.sort()</code>. The function should take a
string as an argument. The default is <code>None</code>.</dd>
<dt><strong><code>include_folders</code></strong>, <strong><code>exclude_folders</code></strong>, <strong><code>include_files</code></strong>, <strong><code>exclude_files</code></strong> :&ensp;<code>str, list-like,</code> or <code>None</code>, optional</dt>
<dd>Folder / file names to include or exclude. The default is <code>None</code>.
By
default, these are interpreted literally.
Pass <code>regex=True</code> for
using regular expressions.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Interpret the strings of include/exclude file/folder arguments as
regular expressions. The default is <code>False</code>.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function for filtering items.
Each individual item object
is passed to the mask function.
If <code>True</code> is returned, the
item is kept.
The default is <code>None</code>.</dd>
<dt><strong><code>formatter</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>
<p>Function for customizing the directory printing logic and style
based on specific folders &amp; files.
When passed, the formatter
is called on each item in the file tree, and the current arguments
are updated based what is returned.</p>
<p>The formatter function should accept a FakeItem as a
single argument (either relative or absolute, depending on what is passed
to the <code>path</code> argument), and it should return either a dictionary or None.
The dictionary should have names of arguments as keys and their respective
setting as values.</p>
<p>The following options can meaningfully be toggled by passing a formatter
function: <code>depthlimit</code>, <code>itemlimit</code>, <code>beyond</code>, <code>first</code>, <code>sort</code>, <code>sort_reverse</code>,
<code>sort_key</code>, <code>include_folders</code>, <code>regex</code>, <code>mask</code>, as well as any seedir token
keywords (<code>extend</code>, <code>space</code>, <code>split</code>, <code>final</code>, <code>folderstart</code>, <code>filestart</code>,
<code>folderend</code>, <code>fileend</code>).</p>
<p>Note that in version 0.3.0, formatter could only be used to update
the style tokens.
It can now be used to udpate those as well as the other
arguments listed above.</p>
<p>If None is returned by formatter, the tokens will be set by <code>style</code>.</p>
<p>Note that items exlcuded by the inclusion/exclusion arguments (or the
<code>mask</code>) <em>will not</em> be seen by formatter.
Similarly, any folder tree
entries created by the <code>beyond</code> argument <em>will not</em> be seen by formatter.</p>
</dd>
<dt><strong><code>sticky_formatter</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True, updates to argumnts made by the <code>formatter</code> (see above)
will be permanent.
Thus, if arguments are updated when the <code>formatter</code>
is called on a folder, its children will (recursively) inherit
those new arguments.</dd>
<dt><strong><code>slash</code></strong> :&ensp;<code>str, option:</code></dt>
<dd>
<p><strong><code>DeprecationWarning</code></strong>: <em>With addition of <code>folderend</code> in v0.3.1,
<code>slash</code> is to be deprecated in a future version.</em></p>
<p>Slash character to follow folders.
If <code>'sep'</code>, uses <code>os.sep</code>.
The
default is <code>'/'</code>.</p>
</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Specific tokens to use for creating the file tree diagram.
The tokens
use by each builtin style can be seen with <code><a title="seedir.printing.get_styleargs" href="printing.html#seedir.printing.get_styleargs">get_styleargs()</a></code>.
Valid options are <code>extend</code> (characters to show the extension of a directory
while its children are traversed), <code>space</code> (character to provide the
correct indentation of an item when some of its parent / grandparent
directories are completely traversed), <code>split</code> (characters to show a
folder or file within a directory, with more items following),
<code>final</code> (characters to show a folder or file within a directory,
with no more items following), <code>folderstart</code> (characters to prepend
before any folder), <code>filestart</code> (characters to preppend before any
file), <code>folderend</code> (characters to append after any folder), and
<code>fileend</code> (characters to append after any file). The following shows
the default tokens for the <code>'lines'</code> style:</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; sd.get_styleargs('lines')
{'split': '├─', 'extend': '│ ', 'space': '  ', 'final': '└─', 'folderstart': '', 'filestart': '', 'folderend': '/', 'fileend': ''}
</code></pre>
<p>All default style tokens are 2 character strings, except for
the file/folder start/end tokens.
Style tokens from <code>**kwargs</code> are not
affected by the indent parameter.
The <code>uniform</code>, <code>anystart</code>, and
<code>anyend</code> parameters can be used to affect multiple style tokens.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>s (str)</code> or <code>None</code></dt>
<dd>The tree diagram (as a string) or None if prinout = True, in which
case the tree diagram is printed in the console.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seedir(self, style=&#39;lines&#39;, printout=True, indent=2, uniform=None,
           anystart=None, anyend=None, depthlimit=None, itemlimit=None,
           beyond=None, first=None, sort=False, sort_reverse=False, sort_key=None,
           include_folders=None, exclude_folders=None, include_files=None,
           exclude_files=None, regex=False, slash=&#39;/&#39;, mask=None,
           formatter=None, sticky_formatter=False, **kwargs):
    &#39;&#39;&#39;

    Create a folder tree diagram for `self`.  `seedir.fakedir.FakeDir` version of
    `seedir.realdir.seedir()` (see its documentation for examples).

    Parameters
    ----------
    style : &#39;lines&#39;, &#39;dash&#39;, &#39;arrow&#39;, &#39;spaces&#39;, &#39;plus&#39;, or &#39;emoji&#39;, optional
        Style to use. The default is `&#39;lines&#39;`.  A style determines the set
        of characters (&#34;tokens&#34;) used to represent the base structure of
        the directory (e.g. which items belong to which folders, when items
        are the last member of a folder, etc.).  The actual tokens being used
        by each style can be viewed with `seedir.printing.get_styleargs()`.
    printout : bool, optional
        Print the folder structure in the console. The default is `True`.  When
        `False`, the folder diagram is returned as a string.
    indent : int (&gt;= 0), optional
        Number of spaces separating items from their parent folder.
        The default is `2`.
    uniform : str or None, optional
        Characters to use for all tokens when creating the tree diagram.
        The default is `None`.  When not `None`, the extend, space, split, and
        final tokens are replaced with `uniform` (the `&#39;spaces&#39;` style is
        essentially `uniform = &#39;  &#39;`).
    anystart : str or None, optional
        Characters to append before any item (i.e. folder or file).  The
        default is `None`.  Specific starts for folders and files can be
        specified (see `**kwargs`).
    anyend : str or None, optional
        Characters to append after any item (i.e. folder or file).  The
        default is `None`.  Specific ends for folders and files can be
        specified (see `**kwargs`).
    depthlimit : int or None, optional
        Limit the depth of folders to traverse.  Folders at the `depthlimit` are
        included, but their contents are not shown (with the exception of the
        beyond parameter being specified).  The default is `None`, which can
        cause exceptionally long runtimes for deep or extensive directories.
    itemlimit : int or None, optional
        Limit the number of items in a directory to show.  Items beyond the
        `itemlimit` can be expressed using the `beyond` parameter.  The files and
        folders left out are determined by the sorting parameters
        (`sort`, `sort_reverse`, `sort_key`).  The default is `None`.
    beyond : str (&#39;ellipsis&#39;, &#39;content&#39; or a string starting with an underscore) or None, optional
        String to indicate directory contents beyond the `itemlimit` or the
        `depthlimit`.  The default is `None`.  Options are: `&#39;ellipsis&#39;` (`&#39;...&#39;`),
        `&#39;content&#39;` or `&#39;contents&#39;` (the number of files and folders beyond), or
        a string starting with `&#39;_&#39;` (everything after the leading underscore
        will be returned)
    first : &#39;files&#39;, &#39;folders&#39;, or None, optional
        Sort the directory so that either files or folders appear first.
        The default is `None`.
    sort : bool, optional
        Sort the directory. With no other specifications, the sort will be a
        simple alphabetical sort of the item names, but this can be altered
        with the `first`, `sort_reverse`, and `sort_key parameters`.
        The default is `False`.
    sort_reverse : bool, optional
        Reverse the sorting determined by `sort` or `sort_key`.
        The default is `False`.
    sort_key : function, optional
        Key to use for sorting file or folder names, akin to the `key` parameter
        of the builtin `sorted()` or `list.sort()`. The function should take a
        string as an argument. The default is `None`.
    include_folders, exclude_folders, include_files, exclude_files : str, list-like, or None, optional
        Folder / file names to include or exclude. The default is `None`.  By
        default, these are interpreted literally.  Pass `regex=True` for
        using regular expressions.
    regex : bool, optional
        Interpret the strings of include/exclude file/folder arguments as
        regular expressions. The default is `False`.
    mask : function, optional
        Function for filtering items.  Each individual item object
        is passed to the mask function.  If `True` is returned, the
        item is kept.  The default is `None`.
    formatter : function, optional
        Function for customizing the directory printing logic and style
        based on specific folders &amp; files.  When passed, the formatter
        is called on each item in the file tree, and the current arguments
        are updated based what is returned.

        The formatter function should accept a FakeItem as a
        single argument (either relative or absolute, depending on what is passed
        to the `path` argument), and it should return either a dictionary or None.
        The dictionary should have names of arguments as keys and their respective
        setting as values.

        The following options can meaningfully be toggled by passing a formatter
        function: `depthlimit`, `itemlimit`, `beyond`, `first`, `sort`, `sort_reverse`,
        `sort_key`, `include_folders`, `regex`, `mask`, as well as any seedir token
        keywords (`extend`, `space`, `split`, `final`, `folderstart`, `filestart`,
        `folderend`, `fileend`).

        Note that in version 0.3.0, formatter could only be used to update
        the style tokens.  It can now be used to udpate those as well as the other
        arguments listed above.

        If None is returned by formatter, the tokens will be set by `style`.

        Note that items exlcuded by the inclusion/exclusion arguments (or the
        `mask`) *will not* be seen by formatter.  Similarly, any folder tree
        entries created by the `beyond` argument *will not* be seen by formatter.

    sticky_formatter : bool, optional
        When True, updates to argumnts made by the `formatter` (see above)
        will be permanent.  Thus, if arguments are updated when the `formatter`
        is called on a folder, its children will (recursively) inherit
        those new arguments.
    slash : str, option:
        **`DeprecationWarning`**: *With addition of `folderend` in v0.3.1,
        `slash` is to be deprecated in a future version.*

        Slash character to follow folders.  If `&#39;sep&#39;`, uses `os.sep`.  The
        default is `&#39;/&#39;`.
    **kwargs : str
        Specific tokens to use for creating the file tree diagram.  The tokens
        use by each builtin style can be seen with `seedir.printing.get_styleargs()`.
        Valid options are `extend` (characters to show the extension of a directory
        while its children are traversed), `space` (character to provide the
        correct indentation of an item when some of its parent / grandparent
        directories are completely traversed), `split` (characters to show a
        folder or file within a directory, with more items following),
        `final` (characters to show a folder or file within a directory,
        with no more items following), `folderstart` (characters to prepend
        before any folder), `filestart` (characters to preppend before any
        file), `folderend` (characters to append after any folder), and
        `fileend` (characters to append after any file). The following shows
        the default tokens for the `&#39;lines&#39;` style:

            &gt;&gt;&gt; import seedir as sd
            &gt;&gt;&gt; sd.get_styleargs(&#39;lines&#39;)
            {&#39;split&#39;: &#39;├─&#39;, &#39;extend&#39;: &#39;│ &#39;, &#39;space&#39;: &#39;  &#39;, &#39;final&#39;: &#39;└─&#39;, &#39;folderstart&#39;: &#39;&#39;, &#39;filestart&#39;: &#39;&#39;, &#39;folderend&#39;: &#39;/&#39;, &#39;fileend&#39;: &#39;&#39;}

        All default style tokens are 2 character strings, except for
        the file/folder start/end tokens.  Style tokens from `**kwargs` are not
        affected by the indent parameter.  The `uniform`, `anystart`, and
        `anyend` parameters can be used to affect multiple style tokens.

    Returns
    -------
    s (str) or None
        The tree diagram (as a string) or None if prinout = True, in which
        case the tree diagram is printed in the console.

    &#39;&#39;&#39;

    # call
    args = dict(style=style,
                printout=printout,
                indent=indent,
                uniform=uniform,
                anystart=anystart,
                anyend=anyend,
                depthlimit=depthlimit,
                itemlimit=itemlimit,
                beyond=beyond,
                first=first,
                sort=sort,
                sort_reverse=sort_reverse,
                sort_key=sort_key,
                include_folders=include_folders,
                exclude_folders=exclude_folders,
                include_files=include_files,
                exclude_files=exclude_files,
                regex=regex,
                mask=mask,
                formatter=formatter,
                sticky_formatter=sticky_formatter,
                **kwargs)

    return FakeDirStructure(self, **args)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.set_child_depths"><code class="name flex">
<span>def <span class="ident">set_child_depths</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively set depths of <code>self</code> and its children.
Called automatically when a new <code>parent</code> is assigned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_child_depths(self):
    &#39;&#39;&#39;Recursively set depths of `self` and its children.
    Called automatically when a new `parent` is assigned.&#39;&#39;&#39;
    def apply_setdepth(FD):
        FD.set_depth()
    self.walk_apply(apply_setdepth)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.trim"><code class="name flex">
<span>def <span class="ident">trim</span></span>(<span>self, depthlimit)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove items beyond the <code>depthlimit</code>.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; r = sd.randomdir(seed=456)
&gt;&gt;&gt; r
MyFakeDir/
├─Vogel.txt
├─monkish.txt
├─jowly.txt
├─scrooge/
│ ├─light.txt
│ ├─reliquary.txt
│ ├─sandal/
│ ├─paycheck/
│ │ ├─electrophoresis.txt
│ │ └─Pyongyang/
│ └─patrimonial/
├─Uganda/
└─pedantic/
  └─cataclysmic.txt

&gt;&gt;&gt; r.trim(1)
&gt;&gt;&gt; r
MyFakeDir/
├─Vogel.txt
├─monkish.txt
├─jowly.txt
├─scrooge/
├─Uganda/
└─pedantic/

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>depthlimit</code></strong> :&ensp;<code>non-negative int</code></dt>
<dd>Files beyond this depth will be cut. The root has depth <code>0</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd><code>depthlimit</code> is not a non-negative int</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim(self, depthlimit):
    &#34;&#34;&#34;
    Remove items beyond the `depthlimit`.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; r = sd.randomdir(seed=456)
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─Vogel.txt
    ├─monkish.txt
    ├─jowly.txt
    ├─scrooge/
    │ ├─light.txt
    │ ├─reliquary.txt
    │ ├─sandal/
    │ ├─paycheck/
    │ │ ├─electrophoresis.txt
    │ │ └─Pyongyang/
    │ └─patrimonial/
    ├─Uganda/
    └─pedantic/
      └─cataclysmic.txt

    &gt;&gt;&gt; r.trim(1)
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─Vogel.txt
    ├─monkish.txt
    ├─jowly.txt
    ├─scrooge/
    ├─Uganda/
    └─pedantic/

    ```


    Parameters
    ----------
    depthlimit : non-negative int
        Files beyond this depth will be cut. The root has depth `0`.

    Raises
    ------
    ValueError
        `depthlimit` is not a non-negative int

    Returns
    -------
    None.

    &#34;&#34;&#34;
    depthlimit = int(depthlimit)
    if depthlimit &lt; 0:
        raise ValueError(&#39;depthlimit must be non-negative int&#39;)
    depthlimit += self.depth
    def trim_apply(f, depthlimit):
        if depthlimit is not None and f.depth == depthlimit:
            if isinstance(f, FakeDir):
                f.delete(f.listdir())
    if depthlimit == self.depth:
        self.delete(self.listdir())
    else:
        self.walk_apply(trim_apply, depthlimit=depthlimit)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeDir.walk_apply"><code class="name flex">
<span>def <span class="ident">walk_apply</span></span>(<span>self, foo, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively apply a function the children of self (and so on)</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; r = sd.randomdir(seed=5)
&gt;&gt;&gt; r
MyFakeDir/
├─senor.txt
├─verb.txt
├─takeoff.txt
├─monastic/
│ ├─paddy.txt
│ ├─ewe.txt
│ ├─advantage.txt
│ ├─hooves/
│ └─registrar/
└─zag/
  ├─thematic.txt
  ├─inelastic.txt
  ├─fierce.txt
  ├─gout/
  └─stein/
    ├─vector.txt
    ├─sora.txt
    └─proviso.txt

&gt;&gt;&gt; def replace_txt(f):
...    f.name = f.name.replace('txt', 'pdf')

&gt;&gt;&gt; r.walk_apply(replace_txt)
&gt;&gt;&gt; r
MyFakeDir/
├─senor.pdf
├─verb.pdf
├─takeoff.pdf
├─monastic/
│ ├─paddy.pdf
│ ├─ewe.pdf
│ ├─advantage.pdf
│ ├─hooves/
│ └─registrar/
└─zag/
  ├─thematic.pdf
  ├─inelastic.pdf
  ├─fierce.pdf
  ├─gout/
  └─stein/
    ├─vector.pdf
    ├─sora.pdf
    └─proviso.pdf

</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>foo</code></strong> :&ensp;<code>function</code></dt>
<dd>Function to apply.</dd>
</dl>
<p><em>args :
Additional positional arguments for <code>foo</code>.
</em>*kwargs :
Additional keyword arguments for <code>foo</code>.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_apply(self, foo, *args, **kwargs):
    &#34;&#34;&#34;
    Recursively apply a function the children of self (and so on)

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; r = sd.randomdir(seed=5)
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─senor.txt
    ├─verb.txt
    ├─takeoff.txt
    ├─monastic/
    │ ├─paddy.txt
    │ ├─ewe.txt
    │ ├─advantage.txt
    │ ├─hooves/
    │ └─registrar/
    └─zag/
      ├─thematic.txt
      ├─inelastic.txt
      ├─fierce.txt
      ├─gout/
      └─stein/
        ├─vector.txt
        ├─sora.txt
        └─proviso.txt

    &gt;&gt;&gt; def replace_txt(f):
    ...    f.name = f.name.replace(&#39;txt&#39;, &#39;pdf&#39;)

    &gt;&gt;&gt; r.walk_apply(replace_txt)
    &gt;&gt;&gt; r
    MyFakeDir/
    ├─senor.pdf
    ├─verb.pdf
    ├─takeoff.pdf
    ├─monastic/
    │ ├─paddy.pdf
    │ ├─ewe.pdf
    │ ├─advantage.pdf
    │ ├─hooves/
    │ └─registrar/
    └─zag/
      ├─thematic.pdf
      ├─inelastic.pdf
      ├─fierce.pdf
      ├─gout/
      └─stein/
        ├─vector.pdf
        ├─sora.pdf
        └─proviso.pdf

    ```

    Parameters
    ----------
    foo : function
        Function to apply.
    *args :
        Additional positional arguments for `foo`.
    **kwargs :
        Additional keyword arguments for `foo`.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    foo(self, *args, **kwargs)
    for f in self._children:
        if isinstance(f, FakeDir):
            f.walk_apply(foo, *args, **kwargs)
        else:
            foo(f, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="seedir.fakedir.FakeItem" href="#seedir.fakedir.FakeItem">FakeItem</a></b></code>:
<ul class="hlist">
<li><code><a title="seedir.fakedir.FakeItem.get_path" href="#seedir.fakedir.FakeItem.get_path">get_path</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.isdir" href="#seedir.fakedir.FakeItem.isdir">isdir</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.isfile" href="#seedir.fakedir.FakeItem.isfile">isfile</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.parent" href="#seedir.fakedir.FakeItem.parent">parent</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.set_depth" href="#seedir.fakedir.FakeItem.set_depth">set_depth</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.siblings" href="#seedir.fakedir.FakeItem.siblings">siblings</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="seedir.fakedir.FakeFile"><code class="flex name class">
<span>class <span class="ident">FakeFile</span></span>
<span>(</span><span>name, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent files in <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> objects.</p>
<p>Files in a <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> have this type.</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; f = sd.randomdir(seed=5) # create a random FakeDir
&gt;&gt;&gt; f
MyFakeDir/
├─senor.txt
├─verb.txt
├─takeoff.txt
├─monastic/
│ ├─paddy.txt
│ ├─ewe.txt
│ ├─advantage.txt
│ ├─hooves/
│ └─registrar/
└─zag/
  ├─thematic.txt
  ├─inelastic.txt
  ├─fierce.txt
  ├─gout/
  └─stein/
    ├─vector.txt
    ├─sora.txt
    └─proviso.txt

&gt;&gt;&gt; f['senor.txt']
FakeFile(MyFakeDir/senor.txt)

</code></pre>
<p>Same as <code><a title="seedir.fakedir.FakeItem" href="#seedir.fakedir.FakeItem">FakeItem</a></code> initialization, but adds
<code>filename</code> and <code>extension</code> attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FakeFile(FakeItem):
    &#39;&#39;&#39;Class to represent files in `seedir.fakedir.FakeDir` objects.

    Files in a `seedir.fakedir.FakeDir` have this type.

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; f = sd.randomdir(seed=5) # create a random FakeDir
    &gt;&gt;&gt; f
    MyFakeDir/
    ├─senor.txt
    ├─verb.txt
    ├─takeoff.txt
    ├─monastic/
    │ ├─paddy.txt
    │ ├─ewe.txt
    │ ├─advantage.txt
    │ ├─hooves/
    │ └─registrar/
    └─zag/
      ├─thematic.txt
      ├─inelastic.txt
      ├─fierce.txt
      ├─gout/
      └─stein/
        ├─vector.txt
        ├─sora.txt
        └─proviso.txt

    &gt;&gt;&gt; f[&#39;senor.txt&#39;]
    FakeFile(MyFakeDir/senor.txt)

    ```

    &#39;&#39;&#39;
    def __init__(self, name, parent=None):
        &#39;&#39;&#39;Same as `seedir.fakedir.FakeItem` initialization, but adds
        `filename` and `extension` attributes.
        &#39;&#39;&#39;
        super().__init__(name, parent)
        self.filename, self.extension = os.path.splitext(self.name)

    def __str__(self):
        return &#39;FakeFile({})&#39;.format(self.get_path())

    def __repr__(self):
        return &#39;FakeFile({})&#39;.format(self.get_path())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="seedir.fakedir.FakeItem" href="#seedir.fakedir.FakeItem">FakeItem</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="seedir.fakedir.FakeItem" href="#seedir.fakedir.FakeItem">FakeItem</a></b></code>:
<ul class="hlist">
<li><code><a title="seedir.fakedir.FakeItem.get_path" href="#seedir.fakedir.FakeItem.get_path">get_path</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.isdir" href="#seedir.fakedir.FakeItem.isdir">isdir</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.isfile" href="#seedir.fakedir.FakeItem.isfile">isfile</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.parent" href="#seedir.fakedir.FakeItem.parent">parent</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.set_depth" href="#seedir.fakedir.FakeItem.set_depth">set_depth</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.siblings" href="#seedir.fakedir.FakeItem.siblings">siblings</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="seedir.fakedir.FakeItem"><code class="flex name class">
<span>class <span class="ident">FakeItem</span></span>
<span>(</span><span>name, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parent class for representing fake folders and files.</p>
<p>Initialize the fake diretory or file object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name for the folder or file.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> or <code>None</code>, optional</dt>
<dd>Parent of <code>self</code>. The default is <code>None</code>, meaning the object will
be the "root" of the directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FakeItem:
    &#39;&#39;&#39;Parent class for representing fake folders and files.&#39;&#39;&#39;
    def __init__(self, name, parent=None):
        &#39;&#39;&#39;
        Initialize the fake diretory or file object.

        Parameters
        ----------
        name : str
            Name for the folder or file.
        parent : seedir.fakedir.FakeDir or None, optional
            Parent of `self`. The default is `None`, meaning the object will
            be the &#34;root&#34; of the directory.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.name = name
        self._parent = None
        self.parent = parent
        self.depth = 0
        self.set_depth()

    @property
    def parent(self):
        &#39;&#39;&#39;
        Getter for the `parent` attribute.

        Returns
        -------
        seedir.fakedir.FakeDir
            The parent folder of the object.

        &#39;&#39;&#39;
        return self._parent

    @parent.setter
    def parent(self, other):
        &#39;&#39;&#39;
        Setter for the `parent` attribute.

        When a new parent is assigned for an object, this method
        verifies that the other object is `seedir.fakedir.FakeDir`, and that the other
        objects children do not contain a fake item with the same name.

        If those conditions are met, `self` is removed from the children
        of its current parent, and its parent attribute is reassigned.
        Depths are also reset.

        Parameters
        ----------
        other : seedir.fakedir.FakeDir
            Fake directory to become the new `parent` for self.

        Raises
        ------
        TypeError
            other is not a `seedir.fakedir.Fakedir`.

        FakedirError
            Name collision: `self.name` is in the child names of other.


        Returns
        -------
        None.

        &#39;&#39;&#39;
        if other:
            if not isinstance(other, FakeDir):
                raise TypeError(&#39;other parameter must be instance of FakeDir&#39;)
            if self.name in other.get_child_names():
                raise FakedirError(&#39;FakeDirs must have unique file/folder names&#39;)
            other._children.append(self)
        if self.parent is not None:
            self.parent._children.remove(self)
        self._parent = other
        self.set_depth()
        if isinstance(self, FakeDir):
            self.set_child_depths()

    def get_path(self):
        &#39;&#39;&#39;Return a &#34;path&#34; string of self, from the head `seedir.fakedir.FakeDir`
        (which has `parent == None`).

        ```
        &gt;&gt;&gt; import seedir as sd
        &gt;&gt;&gt; f = sd.randomdir(seed=5) # create a random FakeDir
        &gt;&gt;&gt; f
        MyFakeDir/
        ├─senor.txt
        ├─verb.txt
        ├─takeoff.txt
        ├─monastic/
        │ ├─paddy.txt
        │ ├─ewe.txt
        │ ├─advantage.txt
        │ ├─hooves/
        │ └─registrar/
        └─zag/
          ├─thematic.txt
          ├─inelastic.txt
          ├─fierce.txt
          ├─gout/
          └─stein/
            ├─vector.txt
            ├─sora.txt
            └─proviso.txt

        &gt;&gt;&gt; x = sd.FakeDir(&#39;newfolder&#39;, parent=f[&#39;zag/stein&#39;])
        &gt;&gt;&gt; x.get_path()
        &#39;MyFakeDir/zag/stein/newfolder&#39;

        ```

        &#39;&#39;&#39;
        parents = [self.name]
        on = self
        while on.parent is not None:
            on = on.parent
            parents.append(on.name)
        return &#39;/&#39;.join(parents[::-1])

    def set_depth(self):
        &#39;&#39;&#39;Set the depth attribute of `self`, based on the depth of parent.
        Automatically called when setting new parents.&#39;&#39;&#39;
        if self.parent is None:
            self.depth = 0
        else:
            self.depth = self.parent.depth + 1

    def isfile(self):
        &#34;&#34;&#34;Returns `True` if instance is a `seedir.fakedir.FakeFile` object&#34;&#34;&#34;
        return isinstance(self, FakeFile)

    def isdir(self):
        &#34;&#34;&#34;Returns True if instance is a `seedir.fakedir.FakeDir` object&#34;&#34;&#34;
        return isinstance(self, FakeDir)

    def siblings(self):
        &#34;&#34;&#34;Returns all the other children of `self.parent`.&#34;&#34;&#34;
        if self.parent is None:
            return []
        else:
            return [f for f in self.parent.listdir() if f is not self]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></li>
<li><a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="seedir.fakedir.FakeItem.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Getter for the <code>parent</code> attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code></dt>
<dd>The parent folder of the object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#39;&#39;&#39;
    Getter for the `parent` attribute.

    Returns
    -------
    seedir.fakedir.FakeDir
        The parent folder of the object.

    &#39;&#39;&#39;
    return self._parent</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="seedir.fakedir.FakeItem.get_path"><code class="name flex">
<span>def <span class="ident">get_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a "path" string of self, from the head <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code>
(which has <code>parent == None</code>).</p>
<pre><code>&gt;&gt;&gt; import seedir as sd
&gt;&gt;&gt; f = sd.randomdir(seed=5) # create a random FakeDir
&gt;&gt;&gt; f
MyFakeDir/
├─senor.txt
├─verb.txt
├─takeoff.txt
├─monastic/
│ ├─paddy.txt
│ ├─ewe.txt
│ ├─advantage.txt
│ ├─hooves/
│ └─registrar/
└─zag/
  ├─thematic.txt
  ├─inelastic.txt
  ├─fierce.txt
  ├─gout/
  └─stein/
    ├─vector.txt
    ├─sora.txt
    └─proviso.txt

&gt;&gt;&gt; x = sd.FakeDir('newfolder', parent=f['zag/stein'])
&gt;&gt;&gt; x.get_path()
'MyFakeDir/zag/stein/newfolder'

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path(self):
    &#39;&#39;&#39;Return a &#34;path&#34; string of self, from the head `seedir.fakedir.FakeDir`
    (which has `parent == None`).

    ```
    &gt;&gt;&gt; import seedir as sd
    &gt;&gt;&gt; f = sd.randomdir(seed=5) # create a random FakeDir
    &gt;&gt;&gt; f
    MyFakeDir/
    ├─senor.txt
    ├─verb.txt
    ├─takeoff.txt
    ├─monastic/
    │ ├─paddy.txt
    │ ├─ewe.txt
    │ ├─advantage.txt
    │ ├─hooves/
    │ └─registrar/
    └─zag/
      ├─thematic.txt
      ├─inelastic.txt
      ├─fierce.txt
      ├─gout/
      └─stein/
        ├─vector.txt
        ├─sora.txt
        └─proviso.txt

    &gt;&gt;&gt; x = sd.FakeDir(&#39;newfolder&#39;, parent=f[&#39;zag/stein&#39;])
    &gt;&gt;&gt; x.get_path()
    &#39;MyFakeDir/zag/stein/newfolder&#39;

    ```

    &#39;&#39;&#39;
    parents = [self.name]
    on = self
    while on.parent is not None:
        on = on.parent
        parents.append(on.name)
    return &#39;/&#39;.join(parents[::-1])</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeItem.isdir"><code class="name flex">
<span>def <span class="ident">isdir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if instance is a <code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdir(self):
    &#34;&#34;&#34;Returns True if instance is a `seedir.fakedir.FakeDir` object&#34;&#34;&#34;
    return isinstance(self, FakeDir)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeItem.isfile"><code class="name flex">
<span>def <span class="ident">isfile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> if instance is a <code><a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isfile(self):
    &#34;&#34;&#34;Returns `True` if instance is a `seedir.fakedir.FakeFile` object&#34;&#34;&#34;
    return isinstance(self, FakeFile)</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeItem.set_depth"><code class="name flex">
<span>def <span class="ident">set_depth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the depth attribute of <code>self</code>, based on the depth of parent.
Automatically called when setting new parents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_depth(self):
    &#39;&#39;&#39;Set the depth attribute of `self`, based on the depth of parent.
    Automatically called when setting new parents.&#39;&#39;&#39;
    if self.parent is None:
        self.depth = 0
    else:
        self.depth = self.parent.depth + 1</code></pre>
</details>
</dd>
<dt id="seedir.fakedir.FakeItem.siblings"><code class="name flex">
<span>def <span class="ident">siblings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all the other children of <code>self.parent</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def siblings(self):
    &#34;&#34;&#34;Returns all the other children of `self.parent`.&#34;&#34;&#34;
    if self.parent is None:
        return []
    else:
        return [f for f in self.parent.listdir() if f is not self]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="seedir" href="index.html">seedir</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="seedir.fakedir.fakedir" href="#seedir.fakedir.fakedir">fakedir</a></code></li>
<li><code><a title="seedir.fakedir.fakedir_fromstring" href="#seedir.fakedir.fakedir_fromstring">fakedir_fromstring</a></code></li>
<li><code><a title="seedir.fakedir.populate" href="#seedir.fakedir.populate">populate</a></code></li>
<li><code><a title="seedir.fakedir.randomdir" href="#seedir.fakedir.randomdir">randomdir</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="seedir.fakedir.FakeDir" href="#seedir.fakedir.FakeDir">FakeDir</a></code></h4>
<ul class="two-column">
<li><code><a title="seedir.fakedir.FakeDir.copy" href="#seedir.fakedir.FakeDir.copy">copy</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.create_file" href="#seedir.fakedir.FakeDir.create_file">create_file</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.create_folder" href="#seedir.fakedir.FakeDir.create_folder">create_folder</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.delete" href="#seedir.fakedir.FakeDir.delete">delete</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.get_child_names" href="#seedir.fakedir.FakeDir.get_child_names">get_child_names</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.listdir" href="#seedir.fakedir.FakeDir.listdir">listdir</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.realize" href="#seedir.fakedir.FakeDir.realize">realize</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.seedir" href="#seedir.fakedir.FakeDir.seedir">seedir</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.set_child_depths" href="#seedir.fakedir.FakeDir.set_child_depths">set_child_depths</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.trim" href="#seedir.fakedir.FakeDir.trim">trim</a></code></li>
<li><code><a title="seedir.fakedir.FakeDir.walk_apply" href="#seedir.fakedir.FakeDir.walk_apply">walk_apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="seedir.fakedir.FakeFile" href="#seedir.fakedir.FakeFile">FakeFile</a></code></h4>
</li>
<li>
<h4><code><a title="seedir.fakedir.FakeItem" href="#seedir.fakedir.FakeItem">FakeItem</a></code></h4>
<ul class="two-column">
<li><code><a title="seedir.fakedir.FakeItem.get_path" href="#seedir.fakedir.FakeItem.get_path">get_path</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.isdir" href="#seedir.fakedir.FakeItem.isdir">isdir</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.isfile" href="#seedir.fakedir.FakeItem.isfile">isfile</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.parent" href="#seedir.fakedir.FakeItem.parent">parent</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.set_depth" href="#seedir.fakedir.FakeItem.set_depth">set_depth</a></code></li>
<li><code><a title="seedir.fakedir.FakeItem.siblings" href="#seedir.fakedir.FakeItem.siblings">siblings</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>