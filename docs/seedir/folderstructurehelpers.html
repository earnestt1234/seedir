<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>seedir.folderstructurehelpers API documentation</title>
<meta name="description" content="Created on Wed May 19 10:29:16 2021 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github-gist.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{background-color:#EBEBEB;line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:white;padding:1px 4px;overflow-wrap:break-word;border-top:1px solid #ccc;border-bottom:1px solid #ccc;border-left:1px solid #ccc;border-right:1px solid #ccc}h1 code{background:transparent;border:transparent}nav code{border:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>seedir.folderstructurehelpers</code></h1>
</header>
<section id="section-intro">
<p>Created on Wed May 19 10:29:16 2021</p>
<p>@author: earne</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Wed May 19 10:29:16 2021

@author: earne
&#34;&#34;&#34;
import os

import natsort

from seedir.errors import SeedirError, FakedirError
import seedir.printing as printing

def count_files(paths):
    &#39;&#39;&#39;
    Count the number of files in a collection of paths.

    Parameters
    ----------
    paths : list-like
        Collection of system paths.

    Returns
    -------
    files : int
        Count of files.

    &#39;&#39;&#39;
    files = sum([os.path.isfile(p) for p in paths])
    return files

def count_fakefiles(objs):
    &#39;&#39;&#39;
    Count the number of FakeFile objections in a collection.

    Parameters
    ----------
    objs : list-like
        Collection of objects (typically FakeDir and FakeFile).

    Returns
    -------
    files : int
        Count of FakeFile objects.

    &#39;&#39;&#39;
    files = sum([p.isfile() for p in objs])
    return files

def count_folders(paths):
    &#39;&#39;&#39;
    Count the number of folders in a collection of paths.

    Parameters
    ----------
    paths : list-like
        Collection of system paths.

    Returns
    -------
    files : int
        Count of folders.

    &#39;&#39;&#39;
    folders = sum([os.path.isdir(p) for p in paths])
    return folders

def count_fakedirs(objs):
    &#39;&#39;&#39;
    Count the number of FakeDir objections in a collection.

    Parameters
    ----------
    objs : list-like
        Collection of objects (typically FakeDir and FakeFile).

    Returns
    -------
    folders : int
        Count of FakeDir objects.

    &#39;&#39;&#39;
    folders = sum([p.isdir() for p in objs])
    return folders

def listdir_fullpath(path):
    return [os.path.join(path, f) for f in os.listdir(path)]

def sort_dir(items, first=None, sort_reverse=False, sort_key=None):
    if sort_key is None:
        key = lambda x : os.path.basename(x)
    else:
        key = lambda x: sort_key(os.path.basename(x))

    if first in [&#39;folders&#39;, &#39;files&#39;]:
        folders = [p for p in items if os.path.isdir(p)]
        files = [p for p in items if not os.path.isdir(p)]
        folders = natsort.natsorted(folders, reverse=sort_reverse, key=key)
        files = natsort.natsorted(files, reverse=sort_reverse, key=key)
        return folders + files if first == &#39;folders&#39; else files + folders
    else:
        return list(natsort.natsorted(items,
                                      reverse=sort_reverse,
                                      key=key))

def sort_fakedir(objs, first=None, sort_reverse=False, sort_key=None):
    &#39;&#39;&#39;
    Sorting function used by seedir.FakeDir.seedir() to sort contents when
    producing folder diagrams.

    Parameters
    ----------
    objs : list-like
        Collection of FakeDir or FakeFile objects to sort.
    first : &#39;files&#39; or &#39;folders&#39;, optional
        Sort either (fake) files or folders first. The default is None.
    sort_reverse : bool, optional
        Reverse the sort applied. The default is False.
    sort_key : function, optional
        Function to apply to sort the objs by their name attribute (i.e. the
        folder or file name).  The function should take a string as a
        parameter.

    Raises
    ------
    SeedirError
        Fails when the &#39;first&#39; parameter is used and no root directory
        is provided.

    Returns
    -------
    list
        Sorted input as a list.

    &#39;&#39;&#39;
    if sort_key is None:
        key = lambda f : f.name
    else:
        key = lambda f : sort_key(f.name)
    if first in [&#39;folders&#39;, &#39;files&#39;]:
        folders = [o for o in objs if o.isdir()]
        files = [o for o in objs if o.isfile()]
        folders = natsort.natsorted(folders, reverse=sort_reverse,
                                    key=key)
        files = natsort.natsorted(files, reverse=sort_reverse, key=key)
        return folders + files if first == &#39;folders&#39; else files + folders
    else:
        return natsort.natsorted(objs, reverse=sort_reverse, key=key)

def beyond_depth_str(paths, beyond):
    &#39;&#39;&#39;
    Generates the text for seedir.seedir() when using the &#39;beyond&#39;
    parameter and ther are more items than the itemlimit or contents
    beyond the depthlimit.

    Parameters
    ----------
    beyond : str
        Style of beyond string to generate.  Options are:
            - &#39;ellipsis&#39; (&#39;...&#39;)
            - &#39;content&#39; or &#39;contents&#39; (the number of files and folders beyond)
            - a string starting with &#39;_&#39; (everything after the leading
              underscore will be returned)
    paths : collection of file paths, optional
        System paths of the items beyond the limit, used when the &#39;beyond&#39;
        argeument is &#39;content&#39; or &#39;contents&#39;. The default is None.

    Raises
    ------
    SeedirError
        Raised when the &#39;beyond&#39; argument is not recognized.

    Returns
    -------
    str
        String indicating what lies beyond

    &#39;&#39;&#39;
    if beyond.lower() == &#39;ellipsis&#39;:
        return &#39;...&#39;
    elif beyond.lower() in [&#39;contents&#39;,&#39;content&#39;]:
        folders = count_folders(paths)
        files = count_files(paths)
        return &#39;{} folder(s), {} file(s)&#39;.format(folders, files)
    elif beyond and beyond[0] == &#39;_&#39;:
        return beyond[1:]
    else:
        s1 = &#39;&#34;beyond&#34; must be &#34;ellipsis&#34;, &#34;content&#34;, or &#39;
        s2 = &#39;a string starting with &#34;_&#34;&#39;
        raise SeedirError(s1 + s2)

def beyond_fakedepth_str(objs, beyond):
    &#39;&#39;&#39;
    Generates the text for seedir.FakeDir.seedir() when using the &#39;beyond&#39;
    parameter and ther are more items than the itemlimit or contents
    beyond the depthlimit.

    Parameters
    ----------
    beyond : str
        Style of beyond string to generate.  Options are:
            - &#39;ellipsis&#39; (&#39;...&#39;)
            - &#39;content&#39; or &#39;contents&#39; (the number of files and folders beyond)
            - a string starting with &#39;_&#39; (everything after the leading
              underscore will be returned)
    objs : collection of FakeDir and FakeFile objects, optional
        Objects beyond the limit, used when the &#39;beyond&#39;
        argeument is &#39;content&#39; or &#39;contents&#39;. The default is None.

    Raises
    ------
    FakedirError
        Raised when the &#39;beyond&#39; argument is not recognized.

    Returns
    -------
    str
        String indicating what lies beyond

    &#39;&#39;&#39;
    if beyond == &#39;ellipsis&#39;:
        return &#39;...&#39;
    elif beyond in [&#39;contents&#39;,&#39;content&#39;]:
        folders = count_fakedirs(objs)
        files = count_fakefiles(objs)
        return &#39;{} folder(s), {} file(s)&#39;.format(folders, files)
    elif beyond and beyond[0] == &#39;_&#39;:
        return beyond[1:]
    else:
        s1 = &#39;&#34;beyond&#34; must be &#34;ellipsis&#34;, &#34;content&#34;, or &#39;
        s2 = &#39;a string starting with &#34;_&#34;&#39;
        raise FakedirError(s1 + s2)

def filter_item_names(items, include_folders=None,
                      exclude_folders=None, include_files=None,
                      exclude_files=None, regex=False,
                      mask=None):
    &#39;&#39;&#39;
    Filter for folder and file names in seedir.seedir().  Removes or includes
    items matching filtering strings.

    Parameters
    ----------
    root : str
        The root path of the items in the listdir arguemnt.
    listdir : list-like
        Collection of file or folder names, under the directory named in the
        root argument.
    include_folders : str or list-like, optional
        Folder names to include. The default is None.
    exclude_folders : str or list-like, optional
        Folder names to exclude. The default is None.
    include_files : str or list-like, optional
        File names to include. The default is None.
    exclude_files : str or list-like, optional
        File names to exclude. The default is None.
    regex : bool, optional
        Interpret strings as regular expressions. The default is False.
    mask : function, optional
        Function for filtering items.  Absolute paths of each individual item
        are passed to the mask function.  If True is returned, the
        item is kept.  The default is None.

    Raises
    ------
    SeedirError
        When the exlcusion or inclusion arguments are not strings or
        iterables.

    Returns
    -------
    keep : list
        Filtered input.

    &#39;&#39;&#39;
    keep = []
    for path in items:
        l = os.path.basename(path)

        if mask is not None:
            if mask(path) is not True:
                continue

        if os.path.isdir(path):
            if isinstance(include_folders, str):
                if not printing.is_match(include_folders, l, regex):
                    continue
            elif include_folders is not None:
                try:
                    if not any(printing.is_match(n, l, regex)
                               for n in include_folders):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;include_folders&#34; and &#39;
                                      &#39;match strings&#39;)
            if isinstance(exclude_folders, str):
                if printing.is_match(exclude_folders, l, regex):
                    continue
            elif exclude_folders is not None:
                try:
                    if any(printing.is_match(x, l, regex)
                           for x in exclude_folders):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_folders&#34; and &#39;
                                      &#39;match strings&#39;)

        else:
            if isinstance(include_files, str):
                if not printing.is_match(include_files, l, regex):
                    continue
            elif include_files is not None:
                try:
                    if not any(printing.is_match(n, l, regex)
                               for n in include_files):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;include_files&#34; and &#39;
                                      &#39;match strings&#39;)
            if isinstance(exclude_files, str):
                if printing.is_match(exclude_files, l, regex):
                    continue
            elif exclude_files is not None:
                try:
                    if any(printing.is_match(x, l, regex)
                           for x in exclude_files):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_files&#34; and &#39;
                                      &#39;match strings&#39;)
        keep.append(path)
    return keep

def filter_fakeitem_names(listdir, include_folders=None,
                          exclude_folders=None, include_files=None,
                          exclude_files=None, regex=False, mask=None):
    &#39;&#39;&#39;
    Filter for folder and file names in seedir.FakeDir.seedir().  Removes or
    includes items matching filtering strings.

    Parameters
    ----------
    listdir : list-like
        Collection of FakeDir and FakeFile objects
    include_folders : str or list-like, optional
        Folder names to include. The default is None.
    exclude_folders : str or list-like, optional
        Folder names to exclude. The default is None.
    include_files : str or list-like, optional
        File names to include. The default is None.
    exclude_files : str or list-like, optional
        File names to exclude. The default is None.
    mask : function, optional
        Function for filtering items.  Each individual item object
        are passed to the mask function.  If True is returned, the
        item is kept.  The default is None.
    regex : bool, optional
        Interpret strings as regular expressions. The default is False.

    Raises
    ------
    SeedirError
        When the exlcusion or inclusion arguments are not strings or
        iterables.

    Returns
    -------
    keep : list
        Filtered input.

    &#39;&#39;&#39;
    keep = []
    for l in listdir:
        if mask is not None:
            if mask(l) is not True:
                continue

        if l.isdir():
            if isinstance(include_folders, str):
                if not printing.is_match(include_folders, l.name, regex):
                    continue
            elif include_folders is not None:
                try:
                    if not any(printing.is_match(n, l.name, regex)
                               for n in include_folders):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                       &#39;over &#34;include_folders&#34; and &#39;
                                       &#39;match strings&#39;)
            if isinstance(exclude_folders, str):
                if printing.is_match(exclude_folders, l.name, regex):
                    continue
            elif exclude_folders is not None:
                try:
                    if any(printing.is_match(x, l.name, regex)
                           for x in exclude_folders):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_folders&#34; and &#39;
                                      &#39;match strings&#39;)
        else:
            if isinstance(include_files, str):
                if not printing.is_match(include_files, l.name, regex):
                    continue
            elif include_files is not None:
                try:
                    if not any(printing.is_match(n, l.name, regex)
                               for n in include_files):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;include_files&#34; and &#39;
                                      &#39;match strings&#39;)
            if isinstance(exclude_files, str):
                if printing.is_match(exclude_files, l.name, regex):
                    continue
            elif exclude_files is not None:
                try:
                    if any(printing.is_match(x, l.name, regex)
                           for x in exclude_files):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_files&#34; and &#39;
                                      &#39;match strings&#39;)
        keep.append(l)
    return keep

def get_base_header(incomplete, extend, space):
    &#39;&#39;&#39;
    For seedir.seedir(), generate the combination of extend and space
    tokens to prepend to file names when generating folder diagrams.
    See the documentation for seedir.seedir() for an
    explanation of these tokens.

    The string generated here will still be missing the branch token
    (split or final) as well as any folderstart or filestart tokens.
    They are added within seedir.seedir().

    For any item included in a folder diagram, the combination of
    extend and space tokens is based on the depth of the item as well as the
    parent folders to that item which are not completed.  This information
    is symbolized with the `incomplete` argument.  The following illustrates
    the incomplete arguments passed to this function for an example folder
    tree:

        &gt;&gt;&gt; #

        doc/
        â”œâ”€_static/                  [0]
        â”‚ â”œâ”€embedded/               [0, 1]
        â”‚ â”‚ â”œâ”€deep_file             [0, 1, 2]
        â”‚ â”‚ â””â”€very/                 [0, 1, 2]
        â”‚ â”‚   â””â”€deep/               [0, 1, 3]
        â”‚ â”‚     â””â”€folder/           [0, 1, 4]
        â”‚ â”‚       â””â”€very_deep_file  [0, 1, 5]
        â”‚ â””â”€less_deep_file          [0, 1]
        â””â”€index.rst                 [0]

    Parameters
    ----------
    incomplete : list-like
        List of integers denoting the depth of incomplete folders at the time
        of constructing the line for a given item.  Zero represents being
        inside the main folder, with increasing integers meaing increasing
        depth.
    extend : str
        Characters symbolizing the extension of a folder.
    space : str
        Characters providing the gap between items and earlier parents.

    Returns
    -------
    str
        Base header string.

    &#39;&#39;&#39;
    base_header = []
    max_i = max(incomplete)
    for p in range(max_i):
        if p in incomplete:
            base_header.append(extend)
        else:
            base_header.append(space)
    return &#34;&#34;.join(base_header)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="seedir.folderstructurehelpers.beyond_depth_str"><code class="name flex">
<span>def <span class="ident">beyond_depth_str</span></span>(<span>paths, beyond)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the text for seedir.seedir() when using the 'beyond'
parameter and ther are more items than the itemlimit or contents
beyond the depthlimit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>beyond</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of beyond string to generate.
Options are:
- 'ellipsis' ('&hellip;')
- 'content' or 'contents' (the number of files and folders beyond)
- a string starting with '_' (everything after the leading
underscore will be returned)</dd>
<dt><strong><code>paths</code></strong> :&ensp;<code>collection</code> of <code>file paths</code>, optional</dt>
<dd>System paths of the items beyond the limit, used when the 'beyond'
argeument is 'content' or 'contents'. The default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SeedirError</code></dt>
<dd>Raised when the 'beyond' argument is not recognized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>String indicating what lies beyond</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beyond_depth_str(paths, beyond):
    &#39;&#39;&#39;
    Generates the text for seedir.seedir() when using the &#39;beyond&#39;
    parameter and ther are more items than the itemlimit or contents
    beyond the depthlimit.

    Parameters
    ----------
    beyond : str
        Style of beyond string to generate.  Options are:
            - &#39;ellipsis&#39; (&#39;...&#39;)
            - &#39;content&#39; or &#39;contents&#39; (the number of files and folders beyond)
            - a string starting with &#39;_&#39; (everything after the leading
              underscore will be returned)
    paths : collection of file paths, optional
        System paths of the items beyond the limit, used when the &#39;beyond&#39;
        argeument is &#39;content&#39; or &#39;contents&#39;. The default is None.

    Raises
    ------
    SeedirError
        Raised when the &#39;beyond&#39; argument is not recognized.

    Returns
    -------
    str
        String indicating what lies beyond

    &#39;&#39;&#39;
    if beyond.lower() == &#39;ellipsis&#39;:
        return &#39;...&#39;
    elif beyond.lower() in [&#39;contents&#39;,&#39;content&#39;]:
        folders = count_folders(paths)
        files = count_files(paths)
        return &#39;{} folder(s), {} file(s)&#39;.format(folders, files)
    elif beyond and beyond[0] == &#39;_&#39;:
        return beyond[1:]
    else:
        s1 = &#39;&#34;beyond&#34; must be &#34;ellipsis&#34;, &#34;content&#34;, or &#39;
        s2 = &#39;a string starting with &#34;_&#34;&#39;
        raise SeedirError(s1 + s2)</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.beyond_fakedepth_str"><code class="name flex">
<span>def <span class="ident">beyond_fakedepth_str</span></span>(<span>objs, beyond)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the text for seedir.FakeDir.seedir() when using the 'beyond'
parameter and ther are more items than the itemlimit or contents
beyond the depthlimit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>beyond</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of beyond string to generate.
Options are:
- 'ellipsis' ('&hellip;')
- 'content' or 'contents' (the number of files and folders beyond)
- a string starting with '_' (everything after the leading
underscore will be returned)</dd>
<dt><strong><code>objs</code></strong> :&ensp;<code>collection</code> of <code>FakeDir and FakeFile objects</code>, optional</dt>
<dd>Objects beyond the limit, used when the 'beyond'
argeument is 'content' or 'contents'. The default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FakedirError</code></dt>
<dd>Raised when the 'beyond' argument is not recognized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>String indicating what lies beyond</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beyond_fakedepth_str(objs, beyond):
    &#39;&#39;&#39;
    Generates the text for seedir.FakeDir.seedir() when using the &#39;beyond&#39;
    parameter and ther are more items than the itemlimit or contents
    beyond the depthlimit.

    Parameters
    ----------
    beyond : str
        Style of beyond string to generate.  Options are:
            - &#39;ellipsis&#39; (&#39;...&#39;)
            - &#39;content&#39; or &#39;contents&#39; (the number of files and folders beyond)
            - a string starting with &#39;_&#39; (everything after the leading
              underscore will be returned)
    objs : collection of FakeDir and FakeFile objects, optional
        Objects beyond the limit, used when the &#39;beyond&#39;
        argeument is &#39;content&#39; or &#39;contents&#39;. The default is None.

    Raises
    ------
    FakedirError
        Raised when the &#39;beyond&#39; argument is not recognized.

    Returns
    -------
    str
        String indicating what lies beyond

    &#39;&#39;&#39;
    if beyond == &#39;ellipsis&#39;:
        return &#39;...&#39;
    elif beyond in [&#39;contents&#39;,&#39;content&#39;]:
        folders = count_fakedirs(objs)
        files = count_fakefiles(objs)
        return &#39;{} folder(s), {} file(s)&#39;.format(folders, files)
    elif beyond and beyond[0] == &#39;_&#39;:
        return beyond[1:]
    else:
        s1 = &#39;&#34;beyond&#34; must be &#34;ellipsis&#34;, &#34;content&#34;, or &#39;
        s2 = &#39;a string starting with &#34;_&#34;&#39;
        raise FakedirError(s1 + s2)</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.count_fakedirs"><code class="name flex">
<span>def <span class="ident">count_fakedirs</span></span>(<span>objs)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of FakeDir objections in a collection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objs</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of objects (typically FakeDir and FakeFile).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>folders</code></strong> :&ensp;<code>int</code></dt>
<dd>Count of FakeDir objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_fakedirs(objs):
    &#39;&#39;&#39;
    Count the number of FakeDir objections in a collection.

    Parameters
    ----------
    objs : list-like
        Collection of objects (typically FakeDir and FakeFile).

    Returns
    -------
    folders : int
        Count of FakeDir objects.

    &#39;&#39;&#39;
    folders = sum([p.isdir() for p in objs])
    return folders</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.count_fakefiles"><code class="name flex">
<span>def <span class="ident">count_fakefiles</span></span>(<span>objs)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of FakeFile objections in a collection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objs</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of objects (typically FakeDir and FakeFile).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>int</code></dt>
<dd>Count of FakeFile objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_fakefiles(objs):
    &#39;&#39;&#39;
    Count the number of FakeFile objections in a collection.

    Parameters
    ----------
    objs : list-like
        Collection of objects (typically FakeDir and FakeFile).

    Returns
    -------
    files : int
        Count of FakeFile objects.

    &#39;&#39;&#39;
    files = sum([p.isfile() for p in objs])
    return files</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.count_files"><code class="name flex">
<span>def <span class="ident">count_files</span></span>(<span>paths)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of files in a collection of paths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of system paths.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>int</code></dt>
<dd>Count of files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_files(paths):
    &#39;&#39;&#39;
    Count the number of files in a collection of paths.

    Parameters
    ----------
    paths : list-like
        Collection of system paths.

    Returns
    -------
    files : int
        Count of files.

    &#39;&#39;&#39;
    files = sum([os.path.isfile(p) for p in paths])
    return files</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.count_folders"><code class="name flex">
<span>def <span class="ident">count_folders</span></span>(<span>paths)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of folders in a collection of paths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of system paths.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>int</code></dt>
<dd>Count of folders.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_folders(paths):
    &#39;&#39;&#39;
    Count the number of folders in a collection of paths.

    Parameters
    ----------
    paths : list-like
        Collection of system paths.

    Returns
    -------
    files : int
        Count of folders.

    &#39;&#39;&#39;
    folders = sum([os.path.isdir(p) for p in paths])
    return folders</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.filter_fakeitem_names"><code class="name flex">
<span>def <span class="ident">filter_fakeitem_names</span></span>(<span>listdir, include_folders=None, exclude_folders=None, include_files=None, exclude_files=None, regex=False, mask=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter for folder and file names in seedir.FakeDir.seedir().
Removes or
includes items matching filtering strings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>listdir</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of FakeDir and FakeFile objects</dd>
<dt><strong><code>include_folders</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>Folder names to include. The default is None.</dd>
<dt><strong><code>exclude_folders</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>Folder names to exclude. The default is None.</dd>
<dt><strong><code>include_files</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>File names to include. The default is None.</dd>
<dt><strong><code>exclude_files</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>File names to exclude. The default is None.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function for filtering items.
Each individual item object
are passed to the mask function.
If True is returned, the
item is kept.
The default is None.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Interpret strings as regular expressions. The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SeedirError</code></dt>
<dd>When the exlcusion or inclusion arguments are not strings or
iterables.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>keep</code></strong> :&ensp;<code>list</code></dt>
<dd>Filtered input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_fakeitem_names(listdir, include_folders=None,
                          exclude_folders=None, include_files=None,
                          exclude_files=None, regex=False, mask=None):
    &#39;&#39;&#39;
    Filter for folder and file names in seedir.FakeDir.seedir().  Removes or
    includes items matching filtering strings.

    Parameters
    ----------
    listdir : list-like
        Collection of FakeDir and FakeFile objects
    include_folders : str or list-like, optional
        Folder names to include. The default is None.
    exclude_folders : str or list-like, optional
        Folder names to exclude. The default is None.
    include_files : str or list-like, optional
        File names to include. The default is None.
    exclude_files : str or list-like, optional
        File names to exclude. The default is None.
    mask : function, optional
        Function for filtering items.  Each individual item object
        are passed to the mask function.  If True is returned, the
        item is kept.  The default is None.
    regex : bool, optional
        Interpret strings as regular expressions. The default is False.

    Raises
    ------
    SeedirError
        When the exlcusion or inclusion arguments are not strings or
        iterables.

    Returns
    -------
    keep : list
        Filtered input.

    &#39;&#39;&#39;
    keep = []
    for l in listdir:
        if mask is not None:
            if mask(l) is not True:
                continue

        if l.isdir():
            if isinstance(include_folders, str):
                if not printing.is_match(include_folders, l.name, regex):
                    continue
            elif include_folders is not None:
                try:
                    if not any(printing.is_match(n, l.name, regex)
                               for n in include_folders):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                       &#39;over &#34;include_folders&#34; and &#39;
                                       &#39;match strings&#39;)
            if isinstance(exclude_folders, str):
                if printing.is_match(exclude_folders, l.name, regex):
                    continue
            elif exclude_folders is not None:
                try:
                    if any(printing.is_match(x, l.name, regex)
                           for x in exclude_folders):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_folders&#34; and &#39;
                                      &#39;match strings&#39;)
        else:
            if isinstance(include_files, str):
                if not printing.is_match(include_files, l.name, regex):
                    continue
            elif include_files is not None:
                try:
                    if not any(printing.is_match(n, l.name, regex)
                               for n in include_files):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;include_files&#34; and &#39;
                                      &#39;match strings&#39;)
            if isinstance(exclude_files, str):
                if printing.is_match(exclude_files, l.name, regex):
                    continue
            elif exclude_files is not None:
                try:
                    if any(printing.is_match(x, l.name, regex)
                           for x in exclude_files):
                        continue
                except:
                    raise FakedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_files&#34; and &#39;
                                      &#39;match strings&#39;)
        keep.append(l)
    return keep</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.filter_item_names"><code class="name flex">
<span>def <span class="ident">filter_item_names</span></span>(<span>items, include_folders=None, exclude_folders=None, include_files=None, exclude_files=None, regex=False, mask=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter for folder and file names in seedir.seedir().
Removes or includes
items matching filtering strings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>str</code></dt>
<dd>The root path of the items in the listdir arguemnt.</dd>
<dt><strong><code>listdir</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of file or folder names, under the directory named in the
root argument.</dd>
<dt><strong><code>include_folders</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>Folder names to include. The default is None.</dd>
<dt><strong><code>exclude_folders</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>Folder names to exclude. The default is None.</dd>
<dt><strong><code>include_files</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>File names to include. The default is None.</dd>
<dt><strong><code>exclude_files</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>File names to exclude. The default is None.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Interpret strings as regular expressions. The default is False.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function for filtering items.
Absolute paths of each individual item
are passed to the mask function.
If True is returned, the
item is kept.
The default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SeedirError</code></dt>
<dd>When the exlcusion or inclusion arguments are not strings or
iterables.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>keep</code></strong> :&ensp;<code>list</code></dt>
<dd>Filtered input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_item_names(items, include_folders=None,
                      exclude_folders=None, include_files=None,
                      exclude_files=None, regex=False,
                      mask=None):
    &#39;&#39;&#39;
    Filter for folder and file names in seedir.seedir().  Removes or includes
    items matching filtering strings.

    Parameters
    ----------
    root : str
        The root path of the items in the listdir arguemnt.
    listdir : list-like
        Collection of file or folder names, under the directory named in the
        root argument.
    include_folders : str or list-like, optional
        Folder names to include. The default is None.
    exclude_folders : str or list-like, optional
        Folder names to exclude. The default is None.
    include_files : str or list-like, optional
        File names to include. The default is None.
    exclude_files : str or list-like, optional
        File names to exclude. The default is None.
    regex : bool, optional
        Interpret strings as regular expressions. The default is False.
    mask : function, optional
        Function for filtering items.  Absolute paths of each individual item
        are passed to the mask function.  If True is returned, the
        item is kept.  The default is None.

    Raises
    ------
    SeedirError
        When the exlcusion or inclusion arguments are not strings or
        iterables.

    Returns
    -------
    keep : list
        Filtered input.

    &#39;&#39;&#39;
    keep = []
    for path in items:
        l = os.path.basename(path)

        if mask is not None:
            if mask(path) is not True:
                continue

        if os.path.isdir(path):
            if isinstance(include_folders, str):
                if not printing.is_match(include_folders, l, regex):
                    continue
            elif include_folders is not None:
                try:
                    if not any(printing.is_match(n, l, regex)
                               for n in include_folders):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;include_folders&#34; and &#39;
                                      &#39;match strings&#39;)
            if isinstance(exclude_folders, str):
                if printing.is_match(exclude_folders, l, regex):
                    continue
            elif exclude_folders is not None:
                try:
                    if any(printing.is_match(x, l, regex)
                           for x in exclude_folders):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_folders&#34; and &#39;
                                      &#39;match strings&#39;)

        else:
            if isinstance(include_files, str):
                if not printing.is_match(include_files, l, regex):
                    continue
            elif include_files is not None:
                try:
                    if not any(printing.is_match(n, l, regex)
                               for n in include_files):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;include_files&#34; and &#39;
                                      &#39;match strings&#39;)
            if isinstance(exclude_files, str):
                if printing.is_match(exclude_files, l, regex):
                    continue
            elif exclude_files is not None:
                try:
                    if any(printing.is_match(x, l, regex)
                           for x in exclude_files):
                        continue
                except:
                    raise SeedirError(&#39;Failure when trying to iterate &#39;
                                      &#39;over &#34;exclude_files&#34; and &#39;
                                      &#39;match strings&#39;)
        keep.append(path)
    return keep</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.get_base_header"><code class="name flex">
<span>def <span class="ident">get_base_header</span></span>(<span>incomplete, extend, space)</span>
</code></dt>
<dd>
<div class="desc"><p>For seedir.seedir(), generate the combination of extend and space
tokens to prepend to file names when generating folder diagrams.
See the documentation for seedir.seedir() for an
explanation of these tokens.</p>
<p>The string generated here will still be missing the branch token
(split or final) as well as any folderstart or filestart tokens.
They are added within seedir.seedir().</p>
<p>For any item included in a folder diagram, the combination of
extend and space tokens is based on the depth of the item as well as the
parent folders to that item which are not completed.
This information
is symbolized with the <code>incomplete</code> argument.
The following illustrates
the incomplete arguments passed to this function for an example folder
tree:</p>
<pre><code>&gt;&gt;&gt; #

doc/
â”œâ”€_static/                  [0]
â”‚ â”œâ”€embedded/               [0, 1]
â”‚ â”‚ â”œâ”€deep_file             [0, 1, 2]
â”‚ â”‚ â””â”€very/                 [0, 1, 2]
â”‚ â”‚   â””â”€deep/               [0, 1, 3]
â”‚ â”‚     â””â”€folder/           [0, 1, 4]
â”‚ â”‚       â””â”€very_deep_file  [0, 1, 5]
â”‚ â””â”€less_deep_file          [0, 1]
â””â”€index.rst                 [0]
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>incomplete</code></strong> :&ensp;<code>list-like</code></dt>
<dd>List of integers denoting the depth of incomplete folders at the time
of constructing the line for a given item.
Zero represents being
inside the main folder, with increasing integers meaing increasing
depth.</dd>
<dt><strong><code>extend</code></strong> :&ensp;<code>str</code></dt>
<dd>Characters symbolizing the extension of a folder.</dd>
<dt><strong><code>space</code></strong> :&ensp;<code>str</code></dt>
<dd>Characters providing the gap between items and earlier parents.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Base header string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_base_header(incomplete, extend, space):
    &#39;&#39;&#39;
    For seedir.seedir(), generate the combination of extend and space
    tokens to prepend to file names when generating folder diagrams.
    See the documentation for seedir.seedir() for an
    explanation of these tokens.

    The string generated here will still be missing the branch token
    (split or final) as well as any folderstart or filestart tokens.
    They are added within seedir.seedir().

    For any item included in a folder diagram, the combination of
    extend and space tokens is based on the depth of the item as well as the
    parent folders to that item which are not completed.  This information
    is symbolized with the `incomplete` argument.  The following illustrates
    the incomplete arguments passed to this function for an example folder
    tree:

        &gt;&gt;&gt; #

        doc/
        â”œâ”€_static/                  [0]
        â”‚ â”œâ”€embedded/               [0, 1]
        â”‚ â”‚ â”œâ”€deep_file             [0, 1, 2]
        â”‚ â”‚ â””â”€very/                 [0, 1, 2]
        â”‚ â”‚   â””â”€deep/               [0, 1, 3]
        â”‚ â”‚     â””â”€folder/           [0, 1, 4]
        â”‚ â”‚       â””â”€very_deep_file  [0, 1, 5]
        â”‚ â””â”€less_deep_file          [0, 1]
        â””â”€index.rst                 [0]

    Parameters
    ----------
    incomplete : list-like
        List of integers denoting the depth of incomplete folders at the time
        of constructing the line for a given item.  Zero represents being
        inside the main folder, with increasing integers meaing increasing
        depth.
    extend : str
        Characters symbolizing the extension of a folder.
    space : str
        Characters providing the gap between items and earlier parents.

    Returns
    -------
    str
        Base header string.

    &#39;&#39;&#39;
    base_header = []
    max_i = max(incomplete)
    for p in range(max_i):
        if p in incomplete:
            base_header.append(extend)
        else:
            base_header.append(space)
    return &#34;&#34;.join(base_header)</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.listdir_fullpath"><code class="name flex">
<span>def <span class="ident">listdir_fullpath</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listdir_fullpath(path):
    return [os.path.join(path, f) for f in os.listdir(path)]</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.sort_dir"><code class="name flex">
<span>def <span class="ident">sort_dir</span></span>(<span>items, first=None, sort_reverse=False, sort_key=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_dir(items, first=None, sort_reverse=False, sort_key=None):
    if sort_key is None:
        key = lambda x : os.path.basename(x)
    else:
        key = lambda x: sort_key(os.path.basename(x))

    if first in [&#39;folders&#39;, &#39;files&#39;]:
        folders = [p for p in items if os.path.isdir(p)]
        files = [p for p in items if not os.path.isdir(p)]
        folders = natsort.natsorted(folders, reverse=sort_reverse, key=key)
        files = natsort.natsorted(files, reverse=sort_reverse, key=key)
        return folders + files if first == &#39;folders&#39; else files + folders
    else:
        return list(natsort.natsorted(items,
                                      reverse=sort_reverse,
                                      key=key))</code></pre>
</details>
</dd>
<dt id="seedir.folderstructurehelpers.sort_fakedir"><code class="name flex">
<span>def <span class="ident">sort_fakedir</span></span>(<span>objs, first=None, sort_reverse=False, sort_key=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sorting function used by seedir.FakeDir.seedir() to sort contents when
producing folder diagrams.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objs</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of FakeDir or FakeFile objects to sort.</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>'files'</code> or <code>'folders'</code>, optional</dt>
<dd>Sort either (fake) files or folders first. The default is None.</dd>
<dt><strong><code>sort_reverse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Reverse the sort applied. The default is False.</dd>
<dt><strong><code>sort_key</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Function to apply to sort the objs by their name attribute (i.e. the
folder or file name).
The function should take a string as a
parameter.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SeedirError</code></dt>
<dd>Fails when the 'first' parameter is used and no root directory
is provided.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Sorted input as a list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_fakedir(objs, first=None, sort_reverse=False, sort_key=None):
    &#39;&#39;&#39;
    Sorting function used by seedir.FakeDir.seedir() to sort contents when
    producing folder diagrams.

    Parameters
    ----------
    objs : list-like
        Collection of FakeDir or FakeFile objects to sort.
    first : &#39;files&#39; or &#39;folders&#39;, optional
        Sort either (fake) files or folders first. The default is None.
    sort_reverse : bool, optional
        Reverse the sort applied. The default is False.
    sort_key : function, optional
        Function to apply to sort the objs by their name attribute (i.e. the
        folder or file name).  The function should take a string as a
        parameter.

    Raises
    ------
    SeedirError
        Fails when the &#39;first&#39; parameter is used and no root directory
        is provided.

    Returns
    -------
    list
        Sorted input as a list.

    &#39;&#39;&#39;
    if sort_key is None:
        key = lambda f : f.name
    else:
        key = lambda f : sort_key(f.name)
    if first in [&#39;folders&#39;, &#39;files&#39;]:
        folders = [o for o in objs if o.isdir()]
        files = [o for o in objs if o.isfile()]
        folders = natsort.natsorted(folders, reverse=sort_reverse,
                                    key=key)
        files = natsort.natsorted(files, reverse=sort_reverse, key=key)
        return folders + files if first == &#39;folders&#39; else files + folders
    else:
        return natsort.natsorted(objs, reverse=sort_reverse, key=key)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="seedir" href="index.html">seedir</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="seedir.folderstructurehelpers.beyond_depth_str" href="#seedir.folderstructurehelpers.beyond_depth_str">beyond_depth_str</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.beyond_fakedepth_str" href="#seedir.folderstructurehelpers.beyond_fakedepth_str">beyond_fakedepth_str</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.count_fakedirs" href="#seedir.folderstructurehelpers.count_fakedirs">count_fakedirs</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.count_fakefiles" href="#seedir.folderstructurehelpers.count_fakefiles">count_fakefiles</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.count_files" href="#seedir.folderstructurehelpers.count_files">count_files</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.count_folders" href="#seedir.folderstructurehelpers.count_folders">count_folders</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.filter_fakeitem_names" href="#seedir.folderstructurehelpers.filter_fakeitem_names">filter_fakeitem_names</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.filter_item_names" href="#seedir.folderstructurehelpers.filter_item_names">filter_item_names</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.get_base_header" href="#seedir.folderstructurehelpers.get_base_header">get_base_header</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.listdir_fullpath" href="#seedir.folderstructurehelpers.listdir_fullpath">listdir_fullpath</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.sort_dir" href="#seedir.folderstructurehelpers.sort_dir">sort_dir</a></code></li>
<li><code><a title="seedir.folderstructurehelpers.sort_fakedir" href="#seedir.folderstructurehelpers.sort_fakedir">sort_fakedir</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>